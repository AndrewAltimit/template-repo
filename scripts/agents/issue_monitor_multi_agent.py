#!/usr/bin/env python3
"""
GitHub Issue Monitoring Agent with Multi-Agent Support

This enhanced version supports multiple AI agents (Claude, Gemini, OpenCode, etc.)
based on the trigger keyword used in the issue/comment.
"""

import json
import logging
import os
import subprocess
import sys
import time
import uuid
from pathlib import Path
from typing import Dict, Optional

from issue_monitor import IssueMonitor as BaseIssueMonitor
from logging_security import get_secure_logger, setup_secure_logging
from multi_agent_subagent_manager import implement_issue_with_agent
from utils import run_gh_command

# Configure logging with security
log_level = logging.DEBUG if os.environ.get("DEBUG") else logging.INFO
logging.basicConfig(level=log_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
setup_secure_logging()
logger = get_secure_logger(__name__)


class MultiAgentIssueMonitor(BaseIssueMonitor):
    """Enhanced Issue Monitor with multi-agent support."""

    def create_pr_from_issue_with_agent(self, issue: Dict, branch_name: str, agent_name: str) -> Optional[str]:
        """Create a pull request to address the issue using the specified agent."""
        issue_number = issue["number"]
        issue_title = issue["title"]

        # First, ensure we're in the repo directory
        repo_name = self.repo.split("/")[-1]
        repo_path = Path.cwd() / repo_name

        try:
            # Clone repo if not already present
            if not repo_path.exists():
                run_gh_command(["repo", "clone", self.repo])

            # Change to repo directory
            os.chdir(repo_path)

            # Create and checkout branch
            subprocess.run(["git", "checkout", "main"], check=True)
            subprocess.run(["git", "pull", "origin", "main"], check=True)
            subprocess.run(["git", "checkout", "-b", branch_name], check=True)

            logger.info(f"Created and checked out branch: {branch_name}")

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to prepare repository: {e}")
            self.post_error_comment(issue_number, f"Failed to prepare repository: {str(e)}")
            return None

        # Use the multi-agent subagent manager to implement the feature
        try:
            logger.info(f"Using {agent_name} agent with tech-lead persona to implement issue #{issue_number}")
            success, output = implement_issue_with_agent(issue, branch_name, agent_name)

            if not success:
                logger.error(f"{agent_name} agent failed: {output}")
                self.post_error_comment(issue_number, f"{agent_name} implementation failed: {output}")
                return None

            logger.info(f"{agent_name} agent completed implementation successfully")

            # Check if there are changes to commit
            status_result = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)

            if not status_result.stdout.strip():
                logger.warning("No changes detected after implementation")
                self.post_error_comment(issue_number, "No changes were made by the implementation")
                return None

            # Create commit
            subprocess.run(["git", "add", "-A"], check=True)

            commit_message = f"Fix issue #{issue_number}: {issue_title}\n\nImplemented by {agent_name} AI Agent"
            subprocess.run(["git", "commit", "-m", commit_message], check=True)

            # Push branch
            subprocess.run(["git", "push", "-u", "origin", branch_name], check=True)

            # Create PR
            pr_body = (
                f"Fixes #{issue_number}\n\n"
                f"## Summary\n"
                f"This PR was automatically generated by the {agent_name} AI Agent "
                f"to address the issue: {issue_title}\n\n"
                f"## Changes\n"
                f"{output[:1000]}...\n\n"  # Include first 1000 chars of implementation output
                f"## Testing\n"
                f"Please review and test the changes thoroughly.\n\n"
                f"---\n"
                f"*Generated by {self.agent_tag} using {agent_name}*"
            )

            pr_result = run_gh_command(
                [
                    "pr",
                    "create",
                    "--repo",
                    self.repo,
                    "--base",
                    "main",
                    "--head",
                    branch_name,
                    "--title",
                    f"Fix issue #{issue_number}: {issue_title}",
                    "--body",
                    pr_body,
                ]
            )

            logger.info(f"Created PR successfully for issue #{issue_number}")
            return pr_result

        except Exception as e:
            logger.error(f"Unexpected error creating PR for issue #{issue_number}: {e}")
            return None

    def process_issues(self):
        """Main process to monitor and handle issues with multi-agent support."""
        logger.info(f"Starting multi-agent issue monitoring for repository: {self.repo}")

        issues = self.get_open_issues()
        logger.info(f"Found {len(issues)} open issues")

        # Log all issue numbers for debugging
        if issues:
            issue_numbers = [issue.get("number", "?") for issue in issues]
            logger.info(f"Issue numbers: {issue_numbers}")

        for issue in issues:
            issue_number = issue["number"]

            # Fetch full comment data for this issue
            comments_output = run_gh_command(
                [
                    "issue",
                    "view",
                    str(issue_number),
                    "--repo",
                    self.repo,
                    "--json",
                    "comments",
                ]
            )

            if comments_output:
                try:
                    comments_data = json.loads(comments_output)
                    issue["comments"] = comments_data.get("comments", [])
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse comments for issue #{issue_number}: {e}")
                    issue["comments"] = []
            else:
                issue["comments"] = []

            # Check for keyword triggers
            trigger_result = self.security_manager.check_trigger_comment(issue, "issue")

            if trigger_result:
                action, agent, trigger_user = trigger_result
                logger.info(f"[TRIGGER] Issue #{issue_number}: [{action}][{agent}] by {trigger_user}")

                # Skip if AI agent has already commented
                if self.has_agent_comment(issue_number):
                    logger.info(f"[SKIP] Issue #{issue_number} already has AI agent comment")
                    continue
                else:
                    logger.info(f"Issue #{issue_number} has no AI agent comment - proceeding")

                # Handle different actions
                if action.lower() in ["approved", "fix", "implement"]:
                    # Analyze issue
                    has_info, missing = self.analyze_issue(issue)

                    if not has_info:
                        # Request more information
                        self.create_information_request_comment(issue_number, missing)
                    elif self.should_create_pr(issue, has_approval_trigger=True):
                        # Check if another agent has already claimed this work
                        if self.has_agent_claimed_work(issue_number):
                            logger.info(f"[SKIP] Another agent has already claimed work on issue #{issue_number}")
                            continue

                        # Generate branch name with UUID suffix
                        uuid_suffix = str(uuid.uuid4())[:6]
                        branch_name = f"fix-issue-{issue_number}-{agent.lower()}-{uuid_suffix}"

                        # Post comment that we're starting work
                        self.post_starting_work_comment(issue_number, branch_name)

                        # Create PR to address the issue using the specified agent
                        self.create_pr_from_issue_with_agent(issue, branch_name, agent)
                    else:
                        logger.info(f"Issue #{issue_number} not actionable yet")

                elif action.lower() == "close":
                    # Close the issue
                    logger.info(f"Closing issue #{issue_number} as requested")
                    run_gh_command(["issue", "close", str(issue_number), "--repo", self.repo])
                    self.create_action_comment(
                        issue_number,
                        f"Issue closed as requested by {trigger_user} using [{action}][{agent}]",
                    )

                elif action.lower() == "summarize":
                    # Summarize the issue
                    logger.info(f"Summarizing issue #{issue_number}")
                    self.create_summary_comment(issue_number, issue)

                else:
                    logger.warning(f"Unknown action: {action}")

            else:
                # No direct trigger, check if issue has enough info and actionable labels
                has_enough_info, missing_fields = self.analyze_issue(issue)

                if not has_enough_info and not self.has_agent_comment(issue_number):
                    # Comment requesting more information
                    self.create_information_request_comment(issue_number, missing_fields)
                elif has_enough_info and self.should_create_pr(issue):
                    logger.info(f"Issue #{issue_number} has enough info and actionable label, " "but no approval trigger")


def main():
    """Main entry point."""
    monitor = MultiAgentIssueMonitor()

    if "--continuous" in sys.argv:
        # Run continuously
        while True:
            try:
                monitor.process_issues()
                time.sleep(300)  # Check every 5 minutes
            except KeyboardInterrupt:
                logger.info("Monitoring stopped by user")
                break
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                time.sleep(60)  # Wait a minute before retrying
    else:
        # Run once
        monitor.process_issues()


if __name__ == "__main__":
    main()
