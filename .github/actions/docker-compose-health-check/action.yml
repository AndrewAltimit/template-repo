name: 'Docker Compose Health Check'
description: 'Start Docker Compose services and wait for them to be healthy'
inputs:
  services:
    description: 'Services to start (space-separated list, or empty for profile-based selection)'
    required: false
    default: ''
  profiles:
    description: 'Docker Compose profiles to activate (comma-separated)'
    required: false
    default: ''
  health-endpoint:
    description: 'Health check endpoint URL'
    required: false
    default: 'http://localhost:8005/health'
  timeout:
    description: 'Timeout in seconds'
    required: false
    default: '60'
  build:
    description: 'Whether to build images'
    required: false
    default: 'true'

runs:
  using: 'composite'
  steps:
    - name: Set unique project name for isolation
      shell: bash
      run: |
        # Use run_id and run_attempt for unique project naming to:
        # 1. Prevent cross-job interference on shared runners
        # 2. Prevent ContainerConfig errors (docker-compose v1 incompatibility with newer Docker)
        #    by ensuring no existing containers to recreate
        PROJECT_NAME="ci-${{ github.run_id }}-${{ github.run_attempt }}"
        echo "COMPOSE_PROJECT_NAME=${PROJECT_NAME}" >> $GITHUB_ENV
        echo "Using Docker Compose project name: ${PROJECT_NAME}"

    - name: Pre-create output directories
      shell: bash
      run: |
        echo "Creating output directories with proper permissions..."
        # Create directories that will be bind-mounted to avoid permission issues
        mkdir -p outputs/mcp-content outputs/mcp-gaea2
        # Ensure they're writable by the current user
        chmod -R 755 outputs/
        echo "Output directories created"

    - name: Set Docker Compose profiles
      shell: bash
      env:
        INPUT_PROFILES: ${{ inputs.profiles }}
      run: |
        if [ -n "$INPUT_PROFILES" ]; then
          echo "Setting Docker Compose profiles: $INPUT_PROFILES"
          echo "COMPOSE_PROFILES=$INPUT_PROFILES" >> $GITHUB_ENV
        fi

    - name: Validate docker-compose configuration
      shell: bash
      env:
        INPUT_SERVICES: ${{ inputs.services }}
      run: |
        echo "Validating docker-compose configuration..."
        docker-compose config

        # Check if any services will be started
        service_count=$(docker-compose config --services | wc -l | tr -d ' ')
        if [ "$service_count" -eq 0 ] && [ -z "$INPUT_SERVICES" ]; then
          echo "ERROR: No services selected!"
          echo "Either specify services explicitly or set profiles to activate services."
          echo "Available profiles in docker-compose.yml:"
          grep -E "^\s*profiles:" docker-compose.yml | sort -u || echo "No profiles found"
          exit 1
        fi

    - name: Start services
      shell: bash
      env:
        INPUT_SERVICES: ${{ inputs.services }}
        INPUT_BUILD: ${{ inputs.build }}
      run: |
        if [ "$INPUT_BUILD" = "true" ]; then
          echo "Building images and starting services..."
          if [ -n "$INPUT_SERVICES" ]; then
            echo "Starting specific services: $INPUT_SERVICES"
            # shellcheck disable=SC2086 - Word splitting is intentional for service names
            docker-compose up --build -d $INPUT_SERVICES
          else
            echo "Starting all services in active profiles"
            docker-compose up --build -d
          fi
        else
          echo "Starting services..."
          if [ -n "$INPUT_SERVICES" ]; then
            echo "Starting specific services: $INPUT_SERVICES"
            # shellcheck disable=SC2086 - Word splitting is intentional for service names
            docker-compose up -d $INPUT_SERVICES
          else
            echo "Starting all services in active profiles"
            docker-compose up -d
          fi
        fi

    - name: Wait for services to be healthy
      shell: bash
      env:
        INPUT_TIMEOUT: ${{ inputs.timeout }}
        INPUT_HEALTH_ENDPOINT: ${{ inputs.health-endpoint }}
      run: |
        echo "Waiting for services to be healthy..."
        elapsed=0
        while [ $elapsed -lt "$INPUT_TIMEOUT" ]; do
          if curl -sf --max-time 5 "$INPUT_HEALTH_ENDPOINT" > /dev/null 2>&1; then
            echo "Services are healthy!"
            break
          fi
          echo -n "."
          sleep 2
          elapsed=$((elapsed + 2))
        done

        if [ $elapsed -ge "$INPUT_TIMEOUT" ]; then
          echo "Timeout waiting for services to be healthy"
          docker-compose ps
          docker-compose logs
          docker-compose down
          exit 1
        fi

        docker-compose ps

    - name: Clean up on failure
      if: failure()
      shell: bash
      run: |
        echo "Cleaning up services..."
        docker-compose down

    - name: Clean up output directories
      if: always()
      shell: bash
      run: |
        # Use the cleanup script that handles permissions properly
        if [ -f automation/ci-cd/cleanup-outputs.sh ]; then
          ./automation/ci-cd/cleanup-outputs.sh
        else
          echo "Warning: Cleanup script not found, skipping cleanup"
        fi
