---
name: Link Check
# Automated link checking for all markdown documentation using containerized Python

'on':
  push:
    branches: [main, refine]
    paths:
      - '**.md'
      - '.github/workflows/link-check.yml'
      - 'scripts/check-markdown-links.py'
      - 'docker/mcp-code-quality.Dockerfile'
      - 'docker/requirements-code-quality.txt'
  pull_request:
    paths:
      - '**.md'
      - '.github/workflows/link-check.yml'
      - 'scripts/check-markdown-links.py'
      - 'docker/mcp-code-quality.Dockerfile'
      - 'docker/requirements-code-quality.txt'
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      check_external:
        description: 'Check external links (slower but more thorough)'
        required: false
        type: boolean
        default: true

concurrency:
  group: link-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  link-check:
    name: Check Documentation Links
    runs-on: [self-hosted, Linux]
    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build MCP Code Quality container
        run: |
          docker build -f docker/mcp-code-quality.Dockerfile -t mcp-code-quality:latest .

      - name: Check markdown links
        id: link_check
        run: |
          # The Python script handles the exit code and GITHUB_OUTPUT directly
          echo "Checking links in markdown files..."

          # Export user to run container as non-root
          export USER_ID=$(id -u)
          export GROUP_ID=$(id -g)

          # Build base docker command
          DOCKER_CMD="docker run --rm --user ${USER_ID}:${GROUP_ID} -v \"${GITHUB_WORKSPACE}\":/workspace -w /workspace"

          # Add GITHUB_OUTPUT mount if available
          if [ -n "${GITHUB_OUTPUT}" ]; then
            GITHUB_OUTPUT_DIR=$(dirname "${GITHUB_OUTPUT}")
            GITHUB_OUTPUT_FILE=$(basename "${GITHUB_OUTPUT}")
            DOCKER_CMD="${DOCKER_CMD} -v \"${GITHUB_OUTPUT_DIR}\":/github -e GITHUB_OUTPUT=/github/${GITHUB_OUTPUT_FILE}"
          fi

          # Run the container with link checker
          # Use eval to properly handle the command with potential spaces in paths
          eval "${DOCKER_CMD} mcp-code-quality:latest \
            python /workspace/scripts/check-markdown-links.py \
              /workspace \
              --format github \
              --output /workspace/link_check_summary.md \
              ${{ github.event.inputs.check_external == 'false' && '--internal-only' || '' }}"

      - name: Upload results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: link-check-results
          path: |
            link_check_summary.md

      - name: Comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = '';

            try {
              summary = fs.readFileSync('link_check_summary.md', 'utf8');
            } catch (e) {
              summary = '## ‚ùå Link Check Failed\n\nCould not read results file.';
            }

            const failed = ${{ steps.link_check.outputs.failed_files || 0 }};

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Link Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }

      - name: Create issue for broken links (scheduled runs)
        if: github.event_name == 'schedule' && steps.link_check.outputs.failed_files != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = '';

            try {
              summary = fs.readFileSync('link_check_summary.md', 'utf8');
            } catch (e) {
              summary = '## ‚ùå Link Check Failed\n\nCould not read results file.';
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üîó Broken links detected in documentation',
              body: summary,
              labels: ['documentation', 'automated', 'link-check']
            });
