---
name: Link Check
# Automated link checking for all markdown documentation using containerized Python

'on':
  push:
    branches: [main, refine]
    paths:
      - '**.md'
      - '.github/workflows/link-check.yml'
      - 'scripts/check-markdown-links.py'
      - 'docker/mcp-code-quality.Dockerfile'
      - 'docker/requirements-code-quality.txt'
  pull_request:
    paths:
      - '**.md'
      - '.github/workflows/link-check.yml'
      - 'scripts/check-markdown-links.py'
      - 'docker/mcp-code-quality.Dockerfile'
      - 'docker/requirements-code-quality.txt'
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      check_external:
        description: 'Check external links (slower but more thorough)'
        required: false
        type: boolean
        default: true

concurrency:
  group: link-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  link-check:
    name: Check Documentation Links
    runs-on: [self-hosted, Linux]
    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build MCP Code Quality container
        run: |
          docker build -f docker/mcp-code-quality.Dockerfile -t mcp-code-quality:latest .

      - name: Check markdown links
        id: link_check
        run: |
          set +e  # Don't exit on error

          # Determine if we should check external links
          check_external="${{ github.event.inputs.check_external }}"
          if [ "$check_external" = "false" ]; then
            check_args="--internal-only"
          else
            check_args=""
          fi

          # Run link check in container
          echo "Checking links in markdown files..."
          docker run --rm \
            -v "${GITHUB_WORKSPACE}:/workspace" \
            -w /workspace \
            mcp-code-quality:latest \
            python /workspace/scripts/check-markdown-links.py \
              /workspace \
              --format github \
              --output /workspace/link_check_summary.md \
              $check_args

          exit_code=$?

          # Set outputs based on results
          if [ -f link_check_summary.md ]; then
            # Extract stats from the markdown file
            broken_count=$(grep -oP 'Broken links\*\*: \K\d+' link_check_summary.md || echo "0")
            total_count=$(grep -oP 'Total links\*\*: \K\d+' link_check_summary.md || echo "0")
            files_count=$(grep -oP 'Files checked\*\*: \K\d+' link_check_summary.md || echo "0")

            echo "failed_files=$broken_count" >> $GITHUB_OUTPUT
            echo "total_errors=$broken_count" >> $GITHUB_OUTPUT
            echo "files_found=$files_count" >> $GITHUB_OUTPUT
          else
            echo "failed_files=0" >> $GITHUB_OUTPUT
            echo "total_errors=0" >> $GITHUB_OUTPUT
            echo "files_found=0" >> $GITHUB_OUTPUT
          fi

          # Exit with appropriate code
          exit $exit_code

      - name: Upload results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: link-check-results
          path: |
            link_check_summary.md

      - name: Comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = '';

            try {
              summary = fs.readFileSync('link_check_summary.md', 'utf8');
            } catch (e) {
              summary = '## ‚ùå Link Check Failed\n\nCould not read results file.';
            }

            const failed = ${{ steps.link_check.outputs.failed_files || 0 }};

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Link Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }

      - name: Create issue for broken links (scheduled runs)
        if: github.event_name == 'schedule' && steps.link_check.outputs.failed_files != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = '';

            try {
              summary = fs.readFileSync('link_check_summary.md', 'utf8');
            } catch (e) {
              summary = '## ‚ùå Link Check Failed\n\nCould not read results file.';
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üîó Broken links detected in documentation',
              body: summary,
              labels: ['documentation', 'automated', 'link-check']
            });
