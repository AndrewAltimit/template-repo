---
# Reusable workflow for AI agent work from GitHub Projects v2 board
#
# Can be triggered:
# 1. Manually via workflow_dispatch
# 2. Called by other workflows via workflow_call
#
# Usage as reusable workflow:
#   jobs:
#     agent-work:
#       uses: ./.github/workflows/board-agent-worker.yml
#       with:
#         agent-name: claude
#       secrets:
#         github-token: ${{ secrets.AGENT_TOKEN }}
#         github-projects-token: ${{ secrets.GITHUB_PROJECTS_TOKEN }}

name: Board Agent Worker

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      agent-name:
        description: 'AI agent to use'
        required: true
        type: choice
        options:
          - claude
          - opencode
          - crush
          - gemini
          - codex
        default: 'claude'
      max-issues:
        description: 'Maximum issues to process'
        required: false
        type: number
        default: 1
      dry-run:
        description: 'Query work but do not execute'
        required: false
        type: boolean
        default: false
      use-docker:
        description: 'Use Docker containers (Claude always runs on host)'
        required: false
        type: boolean
        default: false
      create-pr:
        description: 'Create PR after completing work'
        required: false
        type: boolean
        default: true

  # Reusable workflow
  workflow_call:
    inputs:
      # Agent configuration
      agent-name:
        description: 'AI agent to use'
        required: false
        type: string
        default: 'claude'
      agent-timeout:
        description: 'Timeout for agent execution in minutes'
        required: false
        type: number
        default: 180
      job-timeout-minutes:
        description: 'Job timeout in minutes (0 = use 200 default; set explicitly when using custom agent-timeout)'
        required: false
        type: number
        default: 0

      # Board configuration
      board-config-path:
        description: 'Path to board configuration file'
        required: false
        type: string
        default: 'ai-agents-board.yml'
      max-issues:
        description: 'Maximum number of issues to work on'
        required: false
        type: number
        default: 1

      # Execution modes
      dry-run:
        description: 'Query work but do not execute'
        required: false
        type: boolean
        default: false
      create-pr:
        description: 'Create PR after completing work'
        required: false
        type: boolean
        default: true

      # Label filtering
      include-labels:
        description: 'Comma-separated labels to include (only process issues with these labels)'
        required: false
        type: string
        default: ''
      exclude-labels:
        description: 'Comma-separated labels to exclude (skip issues with these labels)'
        required: false
        type: string
        default: ''

      # Observability
      json-logging:
        description: 'Enable structured JSON logging for log aggregators'
        required: false
        type: boolean
        default: false

      # Janitor settings
      stale-claim-threshold:
        description: 'Hours after which to consider a claim stale and clean it up'
        required: false
        type: number
        default: 2

      # Container configuration
      use-docker:
        description: 'Use Docker containers for agent execution'
        required: false
        type: boolean
        default: true
      docker-compose-file:
        description: 'Path to docker-compose.yml'
        required: false
        type: string
        default: 'docker-compose.yml'

      # Runner configuration
      runs-on:
        description: 'Runner label to use'
        required: false
        type: string
        default: 'self-hosted'

    secrets:
      github-token:
        description: 'GitHub token for repository operations (or uses AGENT_TOKEN)'
        required: false
      github-projects-token:
        description: 'GitHub classic token with project scope (or uses GH_PROJECTS_TOKEN)'
        required: false
      openrouter-api-key:
        description: 'OpenRouter API key for OpenCode/Crush agents (or uses OPENROUTER_API_KEY)'
        required: false
      # Alternate secret names matching repository secrets (for workflow_dispatch)
      AGENT_TOKEN:
        description: 'Repository secret for GitHub token'
        required: false
      GH_PROJECTS_TOKEN:
        description: 'Repository secret for projects token'
        required: false
      OPENROUTER_API_KEY:
        description: 'Repository secret for OpenRouter'
        required: false

    outputs:
      has-work:
        description: 'Whether work was found on the board'
        value: ${{ jobs.agent-work.outputs.has-work }}
      issue-number:
        description: 'Issue number that was worked on'
        value: ${{ jobs.agent-work.outputs.issue-number }}
      issue-title:
        description: 'Title of the issue'
        value: ${{ jobs.agent-work.outputs.issue-title }}
      work-completed:
        description: 'Whether the agent completed work'
        value: ${{ jobs.agent-work.outputs.work-completed }}
      pr-number:
        description: 'PR number if created'
        value: ${{ jobs.agent-work.outputs.pr-number }}
      pr-url:
        description: 'PR URL if created'
        value: ${{ jobs.agent-work.outputs.pr-url }}
      branch-name:
        description: 'Branch name created for work'
        value: ${{ jobs.agent-work.outputs.branch-name }}
      summary-json:
        description: 'JSON summary of work performed'
        value: ${{ jobs.agent-work.outputs.summary-json }}
      stale-claims-cleaned:
        description: 'Number of stale claims cleaned up'
        value: ${{ jobs.agent-work.outputs.stale-claims-cleaned }}

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: board-agent-${{ inputs.agent-name || github.event.inputs.agent-name || 'claude' }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Job 1: Query ready work from board and output as matrix
  # This enables sequential processing of multiple issues with unique branches/PRs
  query-work:
    name: 'Query Ready Work'
    runs-on: ${{ inputs.runs-on || 'self-hosted' }}
    timeout-minutes: 10

    outputs:
      has-work: ${{ steps.query.outputs.has_work }}
      issues-matrix: ${{ steps.query.outputs.issues_matrix }}
      issues-count: ${{ steps.query.outputs.issues_count }}
      stale-claims-cleaned: ${{ steps.janitor.outputs.cleaned_count }}

    steps:
      - name: Pre-checkout cleanup
        uses: ./.github/actions/pre-checkout-cleanup
        with:
          fix-permissions: 'true'

      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 1
          token: ${{ secrets.github-token || secrets.AGENT_TOKEN }}

      - name: Build Rust tools (if needed)
        run: |
          echo "::group::Build Rust Tools"
          BOARD_MANAGER="${GITHUB_WORKSPACE}/tools/rust/board-manager/target/release/board-manager"

          if [ -x "$BOARD_MANAGER" ]; then
            echo "board-manager already exists at $BOARD_MANAGER"
          else
            echo "Building board-manager..."
            cd tools/rust/board-manager
            cargo build --release
            echo "Build complete"
          fi

          # Setup PATH for subsequent steps (use GITHUB_WORKSPACE for absolute path)
          mkdir -p "$HOME/.local/bin"
          ln -sf "${GITHUB_WORKSPACE}/tools/rust/board-manager/target/release/board-manager" "$HOME/.local/bin/board-cli"
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "::endgroup::"

      - name: Janitor - Clean stale claims
        id: janitor
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.github-token || secrets.AGENT_TOKEN }}
          GITHUB_PROJECTS_TOKEN: ${{ secrets.github-projects-token || secrets.GH_PROJECTS_TOKEN }}
          AGENT_NAME: ${{ inputs.agent-name || github.event.inputs.agent-name || 'claude' }}
          STALE_THRESHOLD_HOURS: ${{ inputs.stale-claim-threshold || 2 }}
        run: |
          echo "::group::Janitor - Clean Stale Claims"
          # TODO: Add 'board-manager janitor --agent NAME --threshold HOURS' command
          echo "cleaned_count=0" >> $GITHUB_OUTPUT
          echo "Janitor: Skipped (Rust CLI support pending)"
          echo "::endgroup::"

      - name: Sync approved issues to board
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.github-token || secrets.AGENT_TOKEN }}
          GITHUB_PROJECTS_TOKEN: ${{ secrets.github-projects-token || secrets.GH_PROJECTS_TOKEN }}
          AGENT_NAME: ${{ inputs.agent-name || github.event.inputs.agent-name || 'claude' }}
          BOARD_CONFIG_PATH: ${{ inputs.board-config-path || 'ai-agents-board.yml' }}
        run: |
          echo "::group::Sync Approved Issues"
          echo "Agent: $AGENT_NAME"

          STDERR_FILE=$(mktemp)
          if APPROVED_RESULT=$($HOME/.local/bin/board-cli --format json find-approved --agent "$AGENT_NAME" 2>"$STDERR_FILE"); then
            ISSUE_COUNT=$(echo "$APPROVED_RESULT" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
            echo "Found $ISSUE_COUNT approved issues"

            NOT_ON_BOARD=$(echo "$APPROVED_RESULT" | python3 -c "import sys,json; [print(i['number']) for i in json.load(sys.stdin) if not i.get('on_board', True)]" 2>/dev/null || true)
            for ISSUE_NUM in $NOT_ON_BOARD; do
              echo "Adding issue #$ISSUE_NUM to board..."
              $HOME/.local/bin/board-cli --format json add-to-board "$ISSUE_NUM" --agent "$AGENT_NAME" 2>/dev/null || true
            done
          fi
          rm -f "$STDERR_FILE"
          echo "::endgroup::"

      - name: Query ready work for matrix
        id: query
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.github-token || secrets.AGENT_TOKEN }}
          GITHUB_PROJECTS_TOKEN: ${{ secrets.github-projects-token || secrets.GH_PROJECTS_TOKEN }}
          AGENT_NAME: ${{ inputs.agent-name || github.event.inputs.agent-name || 'claude' }}
          MAX_ISSUES: ${{ inputs.max-issues || github.event.inputs.max-issues || 1 }}
          BOARD_CONFIG_PATH: ${{ inputs.board-config-path || 'ai-agents-board.yml' }}
          INCLUDE_LABELS: ${{ inputs.include-labels || '' }}
          EXCLUDE_LABELS: ${{ inputs.exclude-labels || '' }}
        run: |
          echo "::group::Query Ready Work"
          echo "Agent: $AGENT_NAME"
          echo "Max issues: $MAX_ISSUES"

          # Build board-cli command
          CLI_CMD=($HOME/.local/bin/board-cli --format json ready --limit "$MAX_ISSUES" --approved-only)
          if [ -n "$AGENT_NAME" ]; then
            CLI_CMD+=(--agent "$AGENT_NAME")
          fi

          # Add label filters
          if [ -n "$INCLUDE_LABELS" ]; then
            IFS=',' read -ra LABELS <<< "$INCLUDE_LABELS"
            for label in "${LABELS[@]}"; do
              label=$(echo "$label" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              CLI_CMD+=(--include-labels "$label")
            done
          fi
          if [ -n "$EXCLUDE_LABELS" ]; then
            IFS=',' read -ra LABELS <<< "$EXCLUDE_LABELS"
            for label in "${LABELS[@]}"; do
              label=$(echo "$label" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              CLI_CMD+=(--exclude-labels "$label")
            done
          fi

          echo "Command: ${CLI_CMD[*]}"

          STDERR_FILE=$(mktemp)
          if READY_RESULT=$("${CLI_CMD[@]}" 2>"$STDERR_FILE"); then
            echo "Query result: $READY_RESULT"

            ISSUE_COUNT=$(echo "$READY_RESULT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(len(d) if isinstance(d,list) else 0)" 2>/dev/null || echo "0")
            echo "Found $ISSUE_COUNT ready issues"

            if [ "$ISSUE_COUNT" -gt 0 ]; then
              # Build matrix JSON: array of {issue_number, issue_title} objects
              # Each issue will be processed in its own matrix job
              MATRIX_JSON=$(echo "$READY_RESULT" | python3 -c "import sys,json; issues=json.load(sys.stdin); matrix=[{'issue_number':i.get('number'),'issue_title':i.get('title',''),'issue_labels':','.join(i.get('labels',[]))} for i in issues]; print(json.dumps({'include':matrix}))")
              echo "Matrix: $MATRIX_JSON"

              echo "has_work=true" >> $GITHUB_OUTPUT
              echo "issues_matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
              echo "issues_count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
            else
              echo "has_work=false" >> $GITHUB_OUTPUT
              echo "issues_matrix={\"include\":[]}" >> $GITHUB_OUTPUT
              echo "issues_count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "::error::Query command failed"
            cat "$STDERR_FILE"
            echo "has_work=false" >> $GITHUB_OUTPUT
            echo "issues_matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "issues_count=0" >> $GITHUB_OUTPUT
          fi

          rm -f "$STDERR_FILE"
          echo "::endgroup::"

      - name: Summary
        if: always()
        run: |
          echo "## Query Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Has Work**: ${{ steps.query.outputs.has_work }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Issues Found**: ${{ steps.query.outputs.issues_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Stale Claims Cleaned**: ${{ steps.janitor.outputs.cleaned_count }}" >> $GITHUB_STEP_SUMMARY

  # Job 2: Process each issue sequentially with matrix strategy
  # max-parallel: 1 ensures issues are processed one at a time with unique branches/PRs
  agent-work:
    name: 'Process Issue #${{ matrix.issue_number }}'
    needs: query-work
    if: needs.query-work.outputs.has-work == 'true'
    runs-on: ${{ inputs.runs-on || 'self-hosted' }}
    timeout-minutes: ${{ inputs.job-timeout-minutes > 0 && inputs.job-timeout-minutes || 200 }}

    # Process issues sequentially to avoid conflicts
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.query-work.outputs.issues-matrix) }}

    outputs:
      has-work: ${{ steps.work.outputs.has-work }}
      issue-number: ${{ steps.work.outputs.issue-number }}
      issue-title: ${{ steps.work.outputs.issue-title }}
      work-completed: ${{ steps.work.outputs.work-completed }}
      pr-number: ${{ steps.work.outputs.pr-number }}
      pr-url: ${{ steps.work.outputs.pr-url }}
      branch-name: ${{ steps.work.outputs.branch-name }}
      summary-json: ${{ steps.work.outputs.summary-json }}
      stale-claims-cleaned: ${{ needs.query-work.outputs.stale-claims-cleaned }}

    steps:
      - name: Pre-checkout cleanup
        run: |
          if [ -d "outputs" ] || [ -d "evaluation_results" ] || [ -f ".git/index.lock" ]; then
            docker run --rm -v "$(pwd):/workspace" busybox:1.36.1 sh -c \
              "rm -rf /workspace/outputs /workspace/evaluation_results /workspace/.git/index.lock" || \
              sudo rm -rf outputs evaluation_results .git/index.lock 2>/dev/null || true
          fi
          for dir in .agent-venv __pycache__ .pytest_cache; do
            if [ -d "$dir" ]; then
              docker run --rm -v "$(pwd)/$dir:/target" busybox:1.36.1 \
                chown -Rh "$(id -u):$(id -g)" /target 2>/dev/null || true
            fi
          done

      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          # Use workflow_call secret or fall back to repository secret for workflow_dispatch
          token: ${{ secrets.github-token || secrets.AGENT_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "AI Agent Bot"
          git config --global user.email "ai-agent@localhost"

      - name: Initialize output directories
        run: |
          # Pre-create output directories with correct ownership to prevent
          # Docker from creating them as root (causes permission errors on cleanup)
          if [ -f "./automation/setup/docker/init-output-dirs.sh" ]; then
            bash ./automation/setup/docker/init-output-dirs.sh
          fi

      - name: Build Rust tools (if needed)
        run: |
          echo "::group::Build Rust Tools"
          BOARD_MANAGER="tools/rust/board-manager/target/release/board-manager"

          if [ -x "$BOARD_MANAGER" ]; then
            echo "board-manager already exists at $BOARD_MANAGER"
          else
            echo "Building board-manager..."
            cd tools/rust/board-manager
            cargo build --release
            echo "Build complete"
          fi
          echo "::endgroup::"

      - name: Execute board agent work
        id: work
        uses: ./.github/actions/board-agent-work
        with:
          # Secrets: workflow_call || repository secrets
          github-token: ${{ secrets.github-token || secrets.AGENT_TOKEN }}
          github-projects-token: ${{ secrets.github-projects-token || secrets.GH_PROJECTS_TOKEN }}
          # Inputs: workflow_call || workflow_dispatch || defaults
          agent-name: ${{ inputs.agent-name || github.event.inputs.agent-name || 'claude' }}
          agent-timeout: ${{ inputs.agent-timeout || 180 }}
          board-config-path: ${{ inputs.board-config-path || 'ai-agents-board.yml' }}
          # Pass specific issue from matrix - action will skip query step
          issue-number: ${{ matrix.issue_number }}
          issue-title: ${{ matrix.issue_title }}
          issue-labels: ${{ matrix.issue_labels }}
          # max-issues not needed - we're processing one specific issue
          max-issues: 1
          include-labels: ${{ inputs.include-labels || '' }}
          exclude-labels: ${{ inputs.exclude-labels || '' }}
          dry-run: ${{ inputs.dry-run || github.event.inputs.dry-run || false }}
          # Handle both workflow_dispatch and workflow_call contexts
          # workflow_dispatch: github.event.inputs.create-pr (string 'true'/'false')
          # workflow_call: inputs.create-pr (boolean)
          create-pr: ${{ github.event.inputs.create-pr != 'false' && inputs.create-pr != false }}
          json-logging: ${{ inputs.json-logging || false }}
          stale-claim-threshold: ${{ inputs.stale-claim-threshold || 2 }}
          use-docker: ${{ inputs.use-docker || github.event.inputs.use-docker || false }}
          docker-compose-file: ${{ inputs.docker-compose-file || 'docker-compose.yml' }}
          openrouter-api-key: ${{ secrets.openrouter-api-key || secrets.OPENROUTER_API_KEY }}

      - name: Report results
        if: always()
        run: |
          # The composite action generates a comprehensive Step Summary
          # This step just logs the JSON summary for downstream consumption
          echo "JSON Summary:"
          echo '${{ steps.work.outputs.summary-json }}' | jq . 2>/dev/null || echo '${{ steps.work.outputs.summary-json }}'

      - name: Fix output directory permissions
        if: always()
        run: |
          # Fix ownership of any files created by Docker containers to prevent
          # permission errors on next checkout cleanup
          if [ -d "outputs" ]; then
            # Use Docker to recursively chown since it can access root-owned files
            docker run --rm -v "$(pwd)/outputs:/outputs" alpine:latest \
              chown -R "$(id -u):$(id -g)" /outputs 2>/dev/null || true
          fi
