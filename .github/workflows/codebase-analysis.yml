---
# Daily Codebase Analysis Pipeline
#
# Automatically analyzes the codebase with multiple AI agents and
# creates GitHub issues for discovered improvements. Issues require
# admin approval via [Approved] comment before PRs are created.
#
# STATUS: MANUAL-ONLY - Schedule disabled until ready for production
#
# To enable:
# 1. Uncomment the schedule section
# 2. Configure codebase-analysis-config.yml
# 3. Ensure AGENT_TOKEN and GH_PROJECTS_TOKEN secrets are set

name: Codebase Analysis Pipeline

on:  # yamllint disable-line rule:truthy
  # DISABLED: Uncomment to enable scheduled runs
  # schedule:
  #   # Daily at 3 AM UTC (off-peak hours)
  #   - cron: '0 3 * * *'

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      agents:
        description: 'Agents to use (comma-separated)'
        required: false
        type: string
        default: 'claude,gemini'
      max-issues:
        description: 'Maximum issues to create'
        required: false
        type: number
        default: 3
      min-priority:
        description: 'Minimum priority (P0-P3)'
        required: false
        type: choice
        options:
          - P0
          - P1
          - P2
          - P3
        default: 'P2'
      dry-run:
        description: 'Dry run (analyze but do not create issues)'
        required: false
        type: boolean
        default: true
      include-paths:
        description: 'Paths to analyze (comma-separated globs)'
        required: false
        type: string
        default: 'packages/**/*.py,tools/**/*.py'

permissions:
  contents: read
  issues: write

concurrency:
  group: codebase-analysis
  cancel-in-progress: false

jobs:
  analyze:
    name: Analyze Codebase
    runs-on: self-hosted
    timeout-minutes: 45

    outputs:
      findings-count: ${{ steps.analyze.outputs.findings_count }}
      issues-created: ${{ steps.create.outputs.issues_created }}
      summary-json: ${{ steps.create.outputs.summary_json }}

    steps:
      # Fix Docker-created directory permissions BEFORE checkout
      # Previous runs may have created files as root which blocks checkout cleanup
      # NOTE: Uses Docker (not sudo) to fix permissions - avoids password prompt hangs
      - name: Fix Docker directory permissions (pre-checkout)
        run: |
          echo "::group::Pre-Checkout: Fix Docker Directory Permissions"
          WORKSPACE="${GITHUB_WORKSPACE:-$(pwd)}"

          # List of directories that Docker may have created with root ownership
          # Using direct paths instead of 'find' to avoid hangs on permission-denied dirs
          DIRS_TO_FIX=(
            "outputs"
            "evaluation_results"
            ".agent-venv"
            "__pycache__"
            ".pytest_cache"
          )

          # Fix permissions using Docker (runs as root, no sudo password needed)
          for dir in "${DIRS_TO_FIX[@]}"; do
            # Skip symlinks to prevent chown on unintended paths
            if [ -L "$WORKSPACE/$dir" ]; then
              echo "  Skipping symlink: $WORKSPACE/$dir"
              continue
            fi
            if [ -d "$WORKSPACE/$dir" ]; then
              echo "Fixing ownership via Docker: $WORKSPACE/$dir"
              # Use busybox to chown the directory to the current user
              # -Rh: recursive, affect symlinks themselves (not targets)
              # Use timeout if available to prevent hangs, fall back to direct call
              if command -v timeout &> /dev/null; then
                timeout 30 docker run --rm \
                  -v "$WORKSPACE/$dir:/target" \
                  busybox:1.36.1 \
                  chown -Rh "$(id -u):$(id -g)" /target 2>/dev/null || echo "  Warning: Could not fix $dir (may already have correct ownership)"
              else
                docker run --rm \
                  -v "$WORKSPACE/$dir:/target" \
                  busybox:1.36.1 \
                  chown -Rh "$(id -u):$(id -g)" /target 2>/dev/null || echo "  Warning: Could not fix $dir (may already have correct ownership)"
              fi
            fi
          done

          echo "Permissions check complete"
          echo "::endgroup::"

      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for analysis

      - name: Setup Rust CLI
        run: |
          echo "::group::Setup Rust CLI"
          # Use pre-built Rust binary for github-agents
          RUST_CLI="./tools/rust/github-agents-cli/target/release/github-agents"

          if [ -f "$RUST_CLI" ]; then
            echo "[INFO] Found Rust CLI at $RUST_CLI"
            $RUST_CLI --version || echo "[INFO] Binary exists but no version flag"
          else
            echo "[WARNING] Rust CLI not found at $RUST_CLI"
            echo "[INFO] Building Rust CLI..."
            cd tools/rust/github-agents-cli && cargo build --release
            cd -
          fi

          echo "RUST_CLI=$RUST_CLI" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Load configuration
        id: config
        run: |
          echo "::group::Load Configuration"

          # Use inputs or defaults
          AGENTS="${{ inputs.agents || 'claude,gemini' }}"
          MAX_ISSUES="${{ inputs.max-issues || '3' }}"
          MIN_PRIORITY="${{ inputs.min-priority || 'P2' }}"
          INCLUDE_PATHS="${{ inputs.include-paths || 'packages/**/*.py,tools/**/*.py' }}"
          DRY_RUN="${{ inputs.dry-run }}"

          echo "agents=$AGENTS" >> $GITHUB_OUTPUT
          echo "max_issues=$MAX_ISSUES" >> $GITHUB_OUTPUT
          echo "min_priority=$MIN_PRIORITY" >> $GITHUB_OUTPUT
          echo "include_paths=$INCLUDE_PATHS" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

          echo "Configuration:"
          echo "  Agents: $AGENTS"
          echo "  Max Issues: $MAX_ISSUES"
          echo "  Min Priority: $MIN_PRIORITY"
          echo "  Include Paths: $INCLUDE_PATHS"
          echo "  Dry Run: $DRY_RUN"

          echo "::endgroup::"

      - name: Run codebase analysis
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.AGENT_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          AGENTS: ${{ steps.config.outputs.agents }}
          INCLUDE_PATHS: ${{ steps.config.outputs.include_paths }}
          MIN_PRIORITY: ${{ steps.config.outputs.min_priority }}
          MAX_ISSUES: ${{ steps.config.outputs.max_issues }}
          DRY_RUN: ${{ steps.config.outputs.dry_run }}
        run: |
          echo "::group::Codebase Analysis"

          # Build CLI arguments
          CLI_ARGS="--agents $AGENTS --format json"
          CLI_ARGS="$CLI_ARGS --min-priority $MIN_PRIORITY"
          CLI_ARGS="$CLI_ARGS --max-issues $MAX_ISSUES"

          # Add include paths (convert comma-separated to CLI format)
          if [ -n "$INCLUDE_PATHS" ]; then
            CLI_ARGS="$CLI_ARGS --include-paths $INCLUDE_PATHS"
          fi

          # Add dry-run flag if enabled
          if [ "$DRY_RUN" = "true" ]; then
            CLI_ARGS="$CLI_ARGS --dry-run"
          fi

          echo "[INFO] Running: $RUST_CLI analyze $CLI_ARGS"

          # Run the Rust CLI analyze command
          # The CLI handles both analysis and issue creation
          set +e
          ANALYSIS_OUTPUT=$($RUST_CLI analyze $CLI_ARGS 2>&1)
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            echo "[ERROR] Analysis failed with exit code $EXIT_CODE"
            echo "$ANALYSIS_OUTPUT"
            # Return empty results on failure
            ANALYSIS_OUTPUT='{"findings": [], "count": 0, "created": 0, "skipped": 0, "error": "Analysis failed"}'
          fi

          echo "Analysis output:"
          echo "$ANALYSIS_OUTPUT"

          # Parse results
          FINDINGS_COUNT=$(echo "$ANALYSIS_OUTPUT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('count', 0))" 2>/dev/null || echo "0")
          CREATED_COUNT=$(echo "$ANALYSIS_OUTPUT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('created', 0))" 2>/dev/null || echo "0")

          echo "findings_count=$FINDINGS_COUNT" >> $GITHUB_OUTPUT
          echo "issues_created=$CREATED_COUNT" >> $GITHUB_OUTPUT

          # Pass full findings JSON to next step (escape for multiline)
          {
            echo "findings_json<<EOF"
            echo "$ANALYSIS_OUTPUT"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Create issues from findings
        id: create
        if: steps.analyze.outputs.findings_count != '0'
        env:
          GITHUB_TOKEN: ${{ secrets.AGENT_TOKEN }}
          GITHUB_PROJECTS_TOKEN: ${{ secrets.GH_PROJECTS_TOKEN }}
          DRY_RUN: ${{ steps.config.outputs.dry_run }}
          MAX_ISSUES: ${{ steps.config.outputs.max_issues }}
          MIN_PRIORITY: ${{ steps.config.outputs.min_priority }}
          ANALYSIS_OUTPUT: ${{ steps.analyze.outputs.findings_json }}
        run: |
          echo "::group::Create Issues"

          # Parse findings JSON and process with Rust CLI or gh CLI
          FINDINGS_JSON="$ANALYSIS_OUTPUT"
          FINDINGS_COUNT=$(echo "$FINDINGS_JSON" | python3 -c "import sys,json; print(len(json.load(sys.stdin).get('findings', [])))")

          if [ "$FINDINGS_COUNT" -eq 0 ]; then
            echo "[INFO] No findings to process"
            CREATE_OUTPUT='{"issues_created": 0, "skipped": 0, "errors": 0}'
          elif [ "$DRY_RUN" = "true" ]; then
            echo "[INFO] DRY RUN: Would create up to $MAX_ISSUES issues"
            echo "$FINDINGS_JSON" | python3 -c "
          import sys, json
          data = json.load(sys.stdin)
          for f in data.get('findings', [])[:int('$MAX_ISSUES')]:
              print(f'  - [{f.get(\"priority\", \"P2\")}] {f.get(\"title\", \"untitled\")}')"
            CREATE_OUTPUT="{\"issues_created\": 0, \"would_create\": $FINDINGS_COUNT, \"dry_run\": true}"
          else
            # TODO: Implement issue creation via Rust CLI when 'create-issue' subcommand is available
            # For now, this step won't run since analyze returns 0 findings
            echo "[WARNING] Issue creation via Rust CLI not yet implemented"
            CREATE_OUTPUT='{"issues_created": 0, "note": "Rust create-issue command pending implementation"}'
          fi

          echo "Create output: $CREATE_OUTPUT"

          ISSUES_CREATED=$(echo "$CREATE_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('issues_created', 0))")
          echo "issues_created=$ISSUES_CREATED" >> $GITHUB_OUTPUT

          echo "summary_json=$CREATE_OUTPUT" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Generate summary
        if: always()
        env:
          FINDINGS_COUNT: ${{ steps.analyze.outputs.findings_count }}
          ISSUES_CREATED: ${{ steps.create.outputs.issues_created }}
          DRY_RUN: ${{ steps.config.outputs.dry_run }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Codebase Analysis Pipeline Results

          | Metric | Value |
          |--------|-------|
          | Findings Discovered | ${FINDINGS_COUNT:-0} |
          | Issues Created | ${ISSUES_CREATED:-0} |
          | Dry Run | ${DRY_RUN:-true} |

          ### Configuration
          - **Agents**: ${{ steps.config.outputs.agents }}
          - **Min Priority**: ${{ steps.config.outputs.min_priority }}
          - **Max Issues**: ${{ steps.config.outputs.max_issues }}

          ### Next Steps
          1. Review created issues in the [Issues tab](../../issues)
          2. Approve issues with \`[Approved]\` comment to trigger PR creation
          3. Issue Monitor will create PRs for approved issues

          ---
          *Run: $(date -u '+%Y-%m-%d %H:%M:%S UTC')*
          EOF

      # Fix Docker-created directory permissions after job completion
      # Ensures subsequent runs won't have permission issues during checkout
      # NOTE: Uses Docker (not sudo) to fix permissions - avoids password prompt hangs
      - name: Fix Docker directory permissions (post-cleanup)
        if: always()
        run: |
          echo "::group::Post-Cleanup: Fix Docker Directory Permissions"
          WORKSPACE="${GITHUB_WORKSPACE:-$(pwd)}"

          # List of directories that Docker may have created with root ownership
          DIRS_TO_FIX=(
            "outputs"
            "evaluation_results"
            ".agent-venv"
            "__pycache__"
            ".pytest_cache"
          )

          # Fix permissions using Docker (runs as root, no sudo password needed)
          for dir in "${DIRS_TO_FIX[@]}"; do
            # Skip symlinks to prevent chown on unintended paths
            if [ -L "$WORKSPACE/$dir" ]; then
              echo "  Skipping symlink: $WORKSPACE/$dir"
              continue
            fi
            if [ -d "$WORKSPACE/$dir" ]; then
              echo "Fixing ownership via Docker: $WORKSPACE/$dir"
              # -Rh: recursive, affect symlinks themselves (not targets)
              # Use timeout if available to prevent hangs, fall back to direct call
              if command -v timeout &> /dev/null; then
                timeout 30 docker run --rm \
                  -v "$WORKSPACE/$dir:/target" \
                  busybox:1.36.1 \
                  chown -Rh "$(id -u):$(id -g)" /target 2>/dev/null || echo "  Warning: Could not fix $dir"
              else
                docker run --rm \
                  -v "$WORKSPACE/$dir:/target" \
                  busybox:1.36.1 \
                  chown -Rh "$(id -u):$(id -g)" /target 2>/dev/null || echo "  Warning: Could not fix $dir"
              fi
            fi
          done

          echo "Post-cleanup complete"
          echo "::endgroup::"

  notify:
    name: Notify on Issues Created
    needs: analyze
    runs-on: self-hosted
    if: needs.analyze.outputs.issues-created != '0'

    steps:
      - name: Send notification
        run: |
          echo "Created ${{ needs.analyze.outputs.issues-created }} issues from analysis"

          # CUSTOMIZE: Add notification logic (Slack, email, etc.)
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} ...
