---
name: Pull Request Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, converted_to_draft]
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (for draft PRs)'
        required: false
        type: boolean
        default: false
      force_docker_validation:
        description: 'Force container validation'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  packages: read

concurrency:
  group: pr-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Stage 1: Quick validation and change detection
  detect-changes:
    name: Change Detection & Quick Validation
    runs-on: self-hosted
    timeout-minutes: 5
    outputs:
      python_changed: ${{ steps.changes.outputs.python_changed }}
      yaml_changed: ${{ steps.changes.outputs.yaml_changed }}
      docker_changed: ${{ steps.changes.outputs.docker_changed }}
      mcp_changed: ${{ steps.changes.outputs.mcp_changed }}
      docs_changed: ${{ steps.changes.outputs.docs_changed }}
      sleeper_changed: ${{ steps.changes.outputs.sleeper_changed }}
      dashboard_changed: ${{ steps.changes.outputs.dashboard_changed }}
      ci_changed: ${{ steps.changes.outputs.ci_changed }}
      files_changed: ${{ steps.changes.outputs.files_changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Post-checkout setup
        run: |
          # Initialize output directories to prevent root ownership issues
          if [ -f "./automation/setup/docker/init-output-dirs.sh" ]; then
            ./automation/setup/docker/init-output-dirs.sh
          fi

      - name: Detect file changes
        id: changes
        run: |
          echo "Analyzing changes..."

          # Handle different trigger types
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "PR trigger - comparing with base branch: ${{ github.base_ref }}"
            git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "Push trigger - comparing with previous commit"
            git diff --name-only HEAD~1..HEAD > changed_files.txt
          else
            echo "Manual trigger - comparing with main branch"
            git diff --name-only origin/main...HEAD > changed_files.txt || git diff --name-only HEAD~5..HEAD > changed_files.txt
          fi

          # Count different types of changes
          python_count=$(grep -E '\.(py)$' changed_files.txt | wc -l || echo "0")
          yaml_count=$(grep -E '\.(ya?ml|json)$' changed_files.txt | wc -l || echo "0")
          docker_count=$(grep -E '(Dockerfile|docker-compose\.yml|docker-compose\.yaml|\.dockerignore)' changed_files.txt | wc -l || echo "0")
          mcp_count=$(grep -E '(mcp|MCP|tools/)' changed_files.txt | wc -l || echo "0")
          docs_count=$(grep -E '\.(md|rst|txt)$' changed_files.txt | wc -l || echo "0")
          sleeper_count=$(grep -E '(packages/sleeper_agents|sleeper-evaluation)' changed_files.txt | wc -l || echo "0")
          dashboard_count=$(grep -E '(packages/sleeper_agents/dashboard)' changed_files.txt | wc -l || echo "0")
          ci_count=$(grep -E '(automation/ci-cd|\.github/workflows|docker/)' changed_files.txt | wc -l || echo "0")
          total_files=$(cat changed_files.txt | wc -l)

          # Set outputs
          echo "python_changed=$([[ $python_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "yaml_changed=$([[ $yaml_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "docker_changed=$([[ $docker_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "mcp_changed=$([[ $mcp_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "docs_changed=$([[ $docs_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "sleeper_changed=$([[ $sleeper_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "dashboard_changed=$([[ $dashboard_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "ci_changed=$([[ $ci_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "files_changed=$total_files" >> $GITHUB_OUTPUT

          echo "[INFO] Change Summary:"
          echo "  Python files: $python_count"
          echo "  YAML/JSON files: $yaml_count"
          echo "  Docker files: $docker_count"
          echo "  MCP files: $mcp_count"
          echo "  Documentation: $docs_count"
          echo "  sleeper agents: $sleeper_count"
          echo "  Dashboard: $dashboard_count"
          echo "  CI/CD files: $ci_count"
          echo "  Total files: $total_files"

  # Stage 2: Gemini AI Code Review
  gemini-review:
    name: Gemini AI Code Review
    needs: detect-changes
    if: github.event_name == 'pull_request' && (contains(github.event.pull_request.labels.*.name, 'help wanted') || !github.event.pull_request.draft)
    runs-on: self-hosted
    timeout-minutes: 30  # Increased for large PRs - API calls with retry logic can take time
    outputs:
      is_agent_commit: ${{ steps.check-agent.outputs.is_agent_commit }}  # Informational only
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      PR_TITLE: ${{ github.event.pull_request.title }}
      PR_BODY: ${{ github.event.pull_request.body }}
      PR_AUTHOR: ${{ github.event.pull_request.user.login }}
      BASE_BRANCH: ${{ github.base_ref }}
      HEAD_BRANCH: ${{ github.head_ref }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}  # Free tier API key from Google AI Studio
    steps:
      # No pre-checkout cleanup needed - actions/checkout with clean: true handles this

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      # Log commit info for debugging (reviews always run, agent decides whether to act)
      - name: Log commit info
        id: check-agent
        run: |
          LAST_COMMIT_MSG=$(git log -1 --format='%s')
          LAST_COMMIT_AUTHOR=$(git log -1 --format='%an')

          echo "Last commit message: $LAST_COMMIT_MSG"
          echo "Last commit author: $LAST_COMMIT_AUTHOR"

          # Reviews always run - agent response job decides whether to commit fixes
          # Safety: iteration counter limits to 5 cycles, agent checks for new issues
          IS_AGENT_COMMIT="false"
          if [[ "$LAST_COMMIT_AUTHOR" == "AI Review Agent" ]] || \
             [[ "$LAST_COMMIT_AUTHOR" == "AI Pipeline Agent" ]] || \
             [[ "$LAST_COMMIT_AUTHOR" == "AI Agent Bot" ]]; then
            IS_AGENT_COMMIT="true"
            echo "Agent commit detected - reviews will still run, agent will evaluate if action needed"
          fi

          echo "is_agent_commit=$IS_AGENT_COMMIT" >> $GITHUB_OUTPUT

      # Python cache cleanup not needed with proper user permissions

      - name: Copy changed files list
        # Reviews always run (agent decides whether to act)
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          fi

      # Skip Python setup on self-hosted runner - use system Python

      - name: Setup Node.js with nvm
        # Reviews always run (agent decides whether to act)
        shell: bash
        run: |
          # Source nvm if available
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

          # Use Node.js 22.16.0
          nvm use 22.16.0
          echo "Node.js version: $(node --version)"

          # Verify Gemini CLI is available
          which gemini || echo "Gemini CLI not found in PATH"

      - name: Prepare Gemini review context
        # Reviews always run (agent decides whether to act)
        run: |
          echo "üìã Preparing review context..."
          # Ensure PROJECT_CONTEXT.md is available
          if [ ! -f "PROJECT_CONTEXT.md" ]; then
            echo "Warning: PROJECT_CONTEXT.md not found - Gemini will use fallback context"
          else
            echo "Found PROJECT_CONTEXT.md - Gemini will have full project context"
          fi

      - name: Clear Gemini conversation history
        # Reviews always run (agent decides whether to act)
        continue-on-error: true
        run: |
          echo "üßπ Clearing Gemini conversation history..."
          # Install uv for fast package installation (if not available)
          if ! command -v uv &> /dev/null; then
            curl -LsSf https://astral.sh/uv/install.sh | sh
            export PATH="$HOME/.local/bin:$PATH"
          fi
          # Create temporary venv for MCP packages (avoids polluting system Python)
          uv venv .gemini-venv
          source .gemini-venv/bin/activate
          # Install mcp packages for host execution (10-100x faster with uv)
          uv pip install -e ./tools/mcp/mcp_core
          uv pip install -e ./tools/mcp/mcp_gemini
          # Gemini MCP server must run on host (not in container)
          # Start Gemini MCP server in background
          python -m mcp_gemini.server --mode http &
          GEMINI_PID=$!

          # Wait for server to be ready with health check polling
          echo "‚è≥ Waiting for Gemini server to be ready..."
          for i in {1..30}; do
            if curl -f -s http://localhost:8006/health > /dev/null 2>&1; then
              echo "‚úÖ Gemini server is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå Gemini server failed to start after 30 seconds"
              kill $GEMINI_PID || true
              exit 1
            fi
            echo "  Attempt $i/30..."
            sleep 1
          done

          # Call the clear history endpoint via Gemini MCP server
          curl -X POST http://localhost:8006/mcp/execute \
            -H "Content-Type: application/json" \
            -d '{"tool": "clear_gemini_history", "arguments": {}}' \
            || echo "Warning: Could not clear Gemini history"

          # Stop the Gemini server
          kill $GEMINI_PID || true


      - name: Run Gemini CLI Review
        # Reviews always run (agent decides whether to act)
        continue-on-error: true  # Don't fail the PR if Gemini review fails
        shell: bash
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY || '' }}
        run: |
          # Check API Key
          echo "üîë Checking API Key..."
          if [ -z "${GOOGLE_API_KEY}" ]; then
            echo "‚ùå GOOGLE_API_KEY is empty!"
          else
            echo "‚úÖ GOOGLE_API_KEY is set (length: ${#GOOGLE_API_KEY})"
          fi

          # Run Python script (uses npx internally, no global install needed)
          echo "üöÄ Starting Gemini PR Review..."
          echo "‚ÑπÔ∏è  Using npx to run @google/gemini-cli (no global install)"
          python3 automation/review/gemini-pr-review.py

      - name: Upload review artifact
        if: always() && steps.check-agent.outputs.is_agent_commit != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: gemini-review-${{ github.run_id }}-${{ github.run_attempt }}
          path: gemini-review.md
          retention-days: 7
          if-no-files-found: ignore

  # Stage 2b: Codex AI Code Review (Secondary reviewer with Gemini context)
  codex-review:
    name: Codex AI Code Review
    needs: [detect-changes, gemini-review]
    if: |
      github.event_name == 'pull_request' &&
      (contains(github.event.pull_request.labels.*.name, 'help wanted') || !github.event.pull_request.draft) &&
      needs.gemini-review.result != 'skipped'
    runs-on: self-hosted
    timeout-minutes: 15  # Shorter timeout - Codex is faster
    continue-on-error: true  # Advisory review - don't block PR on Codex failures
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      PR_TITLE: ${{ github.event.pull_request.title }}
      PR_BODY: ${{ github.event.pull_request.body }}
      PR_AUTHOR: ${{ github.event.pull_request.user.login }}
      BASE_BRANCH: ${{ github.base_ref }}
      HEAD_BRANCH: ${{ github.head_ref }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Download Gemini review artifact
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: gemini-review-${{ github.run_id }}-${{ github.run_attempt }}
          path: .

      - name: Setup Node.js with nvm
        shell: bash
        run: |
          # Source nvm if available
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

          # Use Node.js 22.16.0
          nvm use 22.16.0
          echo "Node.js version: $(node --version)"

          # Verify Codex CLI is available
          which codex || echo "Codex CLI not found in PATH"
          codex --version || echo "Could not get Codex version"

      - name: Set Gemini review path
        run: |
          if [ -f "gemini-review.md" ]; then
            echo "GEMINI_REVIEW_PATH=gemini-review.md" >> $GITHUB_ENV
            echo "Found Gemini review artifact"
          else
            echo "No Gemini review artifact found - Codex will review independently"
          fi

      - name: Run Codex CLI Review
        continue-on-error: true  # Don't fail the PR if Codex review fails
        shell: bash
        run: |
          echo "Starting Codex PR Review..."
          python3 automation/review/codex-pr-review.py

      - name: Upload Codex review artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: codex-review-${{ github.run_id }}-${{ github.run_attempt }}
          path: codex-review.md
          retention-days: 7
          if-no-files-found: ignore

  # Stage 2c: Agent Review Response (responds to Gemini/Codex feedback)
  # Always runs - agent evaluates reviews and decides whether to commit fixes
  agent-review-response:
    name: Agent Review Response
    needs: [detect-changes, gemini-review, codex-review]
    if: |
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft &&
      vars.ENABLE_AGENTS == 'true' &&
      !contains(github.event.pull_request.labels.*.name, 'no-auto-fix')
    runs-on: self-hosted
    timeout-minutes: 30
    outputs:
      made_changes: ${{ steps.agent-fix.outputs.made_changes }}
      iteration_count: ${{ steps.iteration.outputs.iteration_count }}
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      HEAD_BRANCH: ${{ github.head_ref }}
      GITHUB_TOKEN: ${{ secrets.AGENT_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.AGENT_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Check iteration count
        id: iteration
        uses: ./.github/actions/agent-iteration-check
        with:
          pr_number: ${{ github.event.pull_request.number }}
          max_iterations: '5'
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Skip if max iterations reached
        if: steps.iteration.outputs.exceeded_max == 'true'
        run: |
          echo "Maximum iterations (5) reached. Manual intervention required."
          echo "made_changes=false" >> $GITHUB_OUTPUT
          exit 0

      - name: Skip if agent commit
        if: steps.iteration.outputs.is_agent_commit == 'true'
        run: |
          echo "Skipping agent response for agent commit"
          echo "made_changes=false" >> $GITHUB_OUTPUT
          exit 0

      - name: Download review artifacts
        if: steps.iteration.outputs.should_skip != 'true'
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: '*-review-${{ github.run_id }}-${{ github.run_attempt }}'
          merge-multiple: true
          path: .

      - name: Setup Node.js with nvm
        if: steps.iteration.outputs.should_skip != 'true'
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          nvm use 22.16.0 || nvm install 22.16.0
          echo "Node.js version: $(node --version)"

      - name: Run agent review response
        id: agent-fix
        if: steps.iteration.outputs.should_skip != 'true'
        env:
          GEMINI_REVIEW_PATH: gemini-review.md
          CODEX_REVIEW_PATH: codex-review.md
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH_NAME: ${{ github.head_ref }}
          ITERATION_COUNT: ${{ steps.iteration.outputs.iteration_count }}
        run: |
          echo "Running agent review response..."
          ./automation/ci-cd/agent-review-response.sh \
            "$PR_NUMBER" \
            "$BRANCH_NAME" \
            "$ITERATION_COUNT" \
            "5"

      - name: Log result
        if: always()
        run: |
          echo "Agent review response completed"
          echo "Made changes: ${{ steps.agent-fix.outputs.made_changes || 'false' }}"
          echo "Iteration: ${{ steps.iteration.outputs.iteration_count }}"

  # Stage 3a: Format check stage (runs after agent has chance to fix review items)
  format-check:
    name: Python Format Check
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: |
      needs.detect-changes.outputs.python_changed == 'true' ||
      needs.detect-changes.outputs.mcp_changed == 'true' ||
      !github.event.pull_request.draft
    uses: ./.github/workflows/lint-stages.yml
    with:
      stage: format
      upload_artifacts: true
    secrets: inherit

  # Stage 3b: Basic lint stage (runs after agent has chance to fix review items)
  basic-lint:
    name: Python Basic Lint
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: |
      needs.detect-changes.outputs.python_changed == 'true' ||
      needs.detect-changes.outputs.mcp_changed == 'true' ||
      !github.event.pull_request.draft
    uses: ./.github/workflows/lint-stages.yml
    with:
      stage: basic
      upload_artifacts: true
    secrets: inherit

  # Stage 3c: Full lint stage (includes security & type checking)
  full-lint:
    name: Python Full Lint
    needs: [detect-changes, gemini-review, codex-review, format-check, basic-lint]
    if: |
      needs.detect-changes.outputs.python_changed == 'true' ||
      needs.detect-changes.outputs.mcp_changed == 'true' ||
      !github.event.pull_request.draft
    uses: ./.github/workflows/lint-stages.yml
    with:
      stage: full
      upload_artifacts: true
    secrets: inherit

  # Stage 3d: Link check for documentation
  link-check:
    name: Documentation Link Check
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: |
      needs.detect-changes.outputs.docs_changed == 'true' ||
      !github.event.pull_request.draft
    uses: ./.github/workflows/lint-stages.yml
    with:
      stage: links
      upload_artifacts: true
    secrets: inherit

  # Stage 4: YAML/JSON validation
  config-validation:
    name: Config File Validation
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: needs.detect-changes.outputs.yaml_changed == 'true'
    runs-on: self-hosted
    timeout-minutes: 10
    steps:
      # No pre-checkout cleanup needed - actions/checkout with clean: true handles this

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Validate YAML and JSON files
        run: |
          echo "üîç Validating configuration files..."
          ./automation/ci-cd/run-ci.sh yaml-lint
          ./automation/ci-cd/run-ci.sh json-lint

  # Stage 4b: Workflow file validation (always run)
  workflow-validation:
    name: Workflow File Validation
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: always() && !cancelled()
    runs-on: self-hosted
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Validate workflow files
        run: |
          echo "üîç Validating GitHub Actions workflow files..."

          # Build the CI image if needed
          docker-compose build python-ci

          # Validate all workflow files
          docker-compose run --rm python-ci bash -c '
            echo "Checking workflow files in .github/workflows/..."
            workflow_errors=0

            for file in .github/workflows/*.yml .github/workflows/*.yaml; do
              if [ -f "$file" ]; then
                echo "Validating: $file"

                # Run yamllint with specific config for workflows
                if yamllint -d "{extends: default, rules: {line-length: {max: 200}, document-start: disable}}" "$file"; then
                  :
                else
                  echo "‚ùå YAML lint failed for $file"
                  workflow_errors=$((workflow_errors + 1))
                fi

                # Validate YAML can be parsed
                if python3 -c "import yaml; yaml.safe_load(open(\"$file\")); print(\"‚úÖ Valid YAML structure: $file\")"; then
                  :
                else
                  echo "‚ùå YAML parse failed for $file"
                  workflow_errors=$((workflow_errors + 1))
                fi
              fi
            done

            if [ $workflow_errors -gt 0 ]; then
              echo "‚ùå Found $workflow_errors workflow file error(s)"
              exit 1
            else
              echo "‚úÖ All workflow files are valid!"
            fi
          '

  # Stage 4c: Comprehensive YAML linting (always run)
  yaml-lint:
    name: YAML Lint All Files
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: always() && !cancelled()
    runs-on: self-hosted
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Run YAML lint on all files
        run: |
          echo "üîç Running comprehensive YAML linting..."
          ./automation/ci-cd/run-ci.sh yaml-lint

  # Stage 5: Test execution
  test-suite:
    name: Test Suite
    needs: [detect-changes, gemini-review, codex-review, agent-review-response, format-check, basic-lint, full-lint]
    if: |
      (needs.detect-changes.outputs.python_changed == 'true' ||
       needs.detect-changes.outputs.mcp_changed == 'true') &&
      !github.event.inputs.skip_tests
    runs-on: self-hosted
    timeout-minutes: 15
    steps:
      # No pre-checkout cleanup needed - actions/checkout with clean: true handles this

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Run tests
        env:
          MCP_GAEA2_URL: http://192.168.0.152:8007
        run: |
          echo "üß™ Running test suite..."
          ./automation/ci-cd/run-ci.sh test

      - name: Generate coverage summary
        if: always()
        run: |
          echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f coverage.xml ]; then
            # Parse coverage.xml for summary stats
            python3 -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()

          # Get overall coverage
          line_rate = float(root.get('line-rate', 0)) * 100
          branch_rate = float(root.get('branch-rate', 0)) * 100

          # Count packages and files
          packages = root.findall('.//package')
          classes = root.findall('.//class')

          print(f'| Metric | Value |')
          print(f'|--------|-------|')
          print(f'| Line Coverage | {line_rate:.1f}% |')
          print(f'| Branch Coverage | {branch_rate:.1f}% |')
          print(f'| Files Analyzed | {len(classes)} |')
          print(f'| Packages | {len(packages)} |')
          " >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìä Full HTML report available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No coverage.xml found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            coverage.xml
            htmlcov/
          retention-days: 14

  # Stage 6: MCP Server validation
  mcp-validation:
    name: MCP Server Validation
    needs: [detect-changes, gemini-review, codex-review, agent-review-response]
    if: |
      needs.detect-changes.outputs.mcp_changed == 'true' &&
      !github.event.pull_request.draft
    runs-on: self-hosted
    timeout-minutes: 10
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      # Clean up any leftover output directories from previous runs
      - name: Clean up output directory
        run: |
          echo "üßπ Cleaning up output directories..."
          # Check if outputs directory exists and has permission issues
          if [ -d "outputs" ]; then
            # Try to remove it normally first
            if rm -rf outputs 2>/dev/null; then
              echo "‚úÖ Outputs directory cleaned"
            else
              # If that fails, try with sudo (if available)
              if command -v sudo &> /dev/null; then
                echo "‚ö†Ô∏è  Permission issues detected, using sudo to clean up"
                sudo rm -rf outputs || echo "‚ùå Could not remove outputs directory even with sudo"
              else
                echo "‚ùå Could not remove outputs directory - permission denied"
              fi
            fi
          fi
          echo "‚úÖ Output cleanup complete"

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Post-checkout setup
        run: |
          # Initialize output directories to prevent root ownership issues
          if [ -f "./automation/setup/docker/init-output-dirs.sh" ]; then
            ./automation/setup/docker/init-output-dirs.sh
          fi

      # Set Docker user environment variables
      - name: Set Docker user environment
        run: |
          source ./automation/setup/docker/set-docker-user.sh

      # No need to install Python or dependencies - Docker handles it

      - name: Start modular MCP servers with health check
        uses: ./.github/actions/docker-compose-health-check
        with:
          services: 'mcp-code-quality mcp-content-creation mcp-gaea2'
          health-endpoint: 'http://localhost:8010/health'
          timeout: '60'
          build: 'true'

      - name: Test MCP servers functionality
        run: |
          echo "ü§ñ Testing modular MCP servers..."

          # Test each server with retries
          echo "Testing Code Quality MCP (port 8010)..."
          for i in {1..15}; do
            if curl -f http://localhost:8010/health 2>/dev/null; then
              echo "‚úÖ Code Quality MCP is ready"
              break
            fi
            if [ $i -eq 15 ]; then
              echo "‚ùå Code Quality MCP failed to respond"
              exit 1
            fi
            echo "  Retry $i/15..."
            sleep 2
          done

          echo "Testing Content Creation MCP (port 8011)..."
          for i in {1..15}; do
            if curl -f http://localhost:8011/health 2>/dev/null; then
              echo "‚úÖ Content Creation MCP is ready"
              break
            fi
            if [ $i -eq 15 ]; then
              echo "‚ùå Content Creation MCP failed to respond"
              exit 1
            fi
            echo "  Retry $i/15..."
            sleep 2
          done

          echo "Testing Gaea2 MCP (port 8007)..."
          for i in {1..15}; do
            if curl -f http://localhost:8007/health 2>/dev/null; then
              echo "‚úÖ Gaea2 MCP is ready"
              break
            fi
            if [ $i -eq 15 ]; then
              echo "‚ùå Gaea2 MCP failed to respond"
              exit 1
            fi
            echo "  Retry $i/15..."
            sleep 2
          done

          # Run comprehensive tests
          docker-compose run --rm python-ci python automation/testing/test_all_servers.py --quick

      - name: View MCP server logs
        if: failure()
        run: |
          echo "üìã MCP server logs:"
          docker-compose logs mcp-code-quality mcp-content-creation mcp-gaea2

      - name: Stop MCP server
        if: always()
        run: |
          # --rmi local removes images built by compose (not public images)
          docker-compose down --rmi local
          # Clean up output directories using Docker to handle permissions
          ./automation/ci-cd/cleanup-outputs.sh

  # Stage 7: sleeper agents Tests
  sleeper-agents-tests:
    name: sleeper agents Tests
    needs: [detect-changes, format-check, basic-lint]
    if: needs.detect-changes.outputs.sleeper_changed == 'true'
    uses: ./.github/workflows/sleeper-agents-tests.yml
    secrets: inherit

  # Stage 7b: Dashboard Tests
  dashboard-tests:
    name: Dashboard Tests
    needs: [detect-changes, format-check, basic-lint]
    if: needs.detect-changes.outputs.dashboard_changed == 'true'
    uses: ./.github/workflows/dashboard-tests.yml
    secrets: inherit

  # Stage 8: Gaea2 MCP Integration Tests
  gaea2-integration-tests:
    name: Gaea2 MCP Integration Tests
    needs: [detect-changes]
    if: needs.detect-changes.outputs.mcp_changed == 'true'
    uses: ./.github/workflows/gaea2-integration-tests.yml
    with:
      server_url: 'http://192.168.0.152:8007'
      run_regression: true
      update_baselines: false

  # Stage 8: Docker image validation
  docker-validation:
    name: Docker Image Validation
    needs: [detect-changes, gemini-review, codex-review, agent-review-response, format-check, basic-lint, full-lint]
    if: |
      (needs.detect-changes.outputs.docker_changed == 'true' ||
       needs.detect-changes.outputs.python_changed == 'true' ||
       github.event.inputs.force_docker_validation) &&
      !github.event.pull_request.draft
    runs-on: self-hosted
    timeout-minutes: 45  # Increased from 30 - builds can take 40+ minutes on cold cache
    steps:
      # No pre-checkout cleanup needed - actions/checkout with clean: true handles this

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=pr
            type=sha,prefix=pr-${{ github.event.pull_request.number }}-

      # Note: Docker builds intentionally do not use GitHub Actions cache (cache-from/cache-to)
      # to avoid cache service availability issues. The self-hosted runner's local Docker
      # cache provides sufficient caching for our needs.
      - name: Build Code Quality MCP image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/mcp-code-quality.Dockerfile
          push: false
          # Load image into Docker daemon. Required for docker-compose health checks.
          load: true
          tags: |
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-code-quality
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-code-quality-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Build Content Creation MCP image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/mcp-content.Dockerfile
          push: false
          # Load image into Docker daemon. Required for docker-compose health checks.
          load: true
          tags: |
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-content
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-content-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Build Gaea2 MCP image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/mcp-gaea2.Dockerfile
          push: false
          # Load image into Docker daemon. Required for docker-compose health checks.
          load: true
          tags: |
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-gaea2
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-gaea2-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Build MCP HTTP Bridge image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/mcp-http-bridge.Dockerfile
          push: false
          # Load image into Docker daemon. Required for docker-compose health checks.
          load: true
          tags: |
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-http-bridge
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-mcp-http-bridge-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Build Python CI image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/python-ci.Dockerfile
          push: false
          # Load image into Docker daemon. Required for docker-compose health checks.
          load: true
          tags: |
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-python-ci
            ${{ env.REGISTRY }}/andrewaltimit/template-repo:pr-${{ github.event.pull_request.number }}-python-ci-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Test Docker Compose with health check
        uses: ./.github/actions/docker-compose-health-check
        with:
          services: 'mcp-code-quality mcp-content-creation mcp-gaea2'
          health-endpoint: 'http://localhost:8010/health'
          timeout: '60'
          build: 'true'

      - name: Cleanup PR-specific images
        if: always()
        uses: ./.github/actions/docker-cleanup
        with:
          image-pattern: 'pr-${{ github.event.pull_request.number }}-'
          prune-dangling: true

      - name: Stop services
        if: always()
        run: |
          # --rmi local removes images built by compose (not public images)
          docker-compose down --rmi local
          # Clean up output directories using Docker to handle permissions
          ./automation/ci-cd/cleanup-outputs.sh

  # Agent Failure Handler - attempts to fix format/lint failures
  agent-failure-handler:
    name: Agent Failure Handler
    needs:
      - detect-changes
      - gemini-review
      - codex-review
      - agent-review-response
      - format-check
      - basic-lint
      - full-lint
    if: |
      failure() &&
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft &&
      vars.ENABLE_AGENTS == 'true' &&
      !contains(github.event.pull_request.labels.*.name, 'no-auto-fix') &&
      (needs.format-check.result == 'failure' ||
       needs.basic-lint.result == 'failure' ||
       needs.full-lint.result == 'failure')
    runs-on: self-hosted
    timeout-minutes: 45
    outputs:
      made_changes: ${{ steps.agent-fix.outputs.made_changes }}
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      HEAD_BRANCH: ${{ github.head_ref }}
      GITHUB_TOKEN: ${{ secrets.AGENT_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
      FORMAT_CHECK_RESULT: ${{ needs.format-check.result }}
      BASIC_LINT_RESULT: ${{ needs.basic-lint.result }}
      FULL_LINT_RESULT: ${{ needs.full-lint.result }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          clean: true
          token: ${{ secrets.AGENT_TOKEN }}
          ref: ${{ github.head_ref }}
          lfs: true

      - name: Check iteration count
        id: iteration
        uses: ./.github/actions/agent-iteration-check
        with:
          pr_number: ${{ github.event.pull_request.number }}
          max_iterations: '5'
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Skip if max iterations reached
        if: steps.iteration.outputs.exceeded_max == 'true'
        run: |
          echo "Maximum iterations (5) reached. Manual intervention required."

          # Post comment on PR
          gh pr comment "${{ github.event.pull_request.number }}" --body "$(cat << 'EOF'
          ## Agent Failure Handler - Max Iterations Reached

          The automated agent has attempted to fix pipeline failures 5 times without success.
          Manual intervention is required to resolve the remaining issues.

          **Failed checks:**
          - Format Check: ${{ needs.format-check.result }}
          - Basic Lint: ${{ needs.basic-lint.result }}
          - Full Lint: ${{ needs.full-lint.result }}

          Please review the failure logs and fix the issues manually.
          EOF
          )"

          echo "made_changes=false" >> $GITHUB_OUTPUT
          exit 0

      - name: Setup Node.js with nvm
        if: steps.iteration.outputs.exceeded_max != 'true'
        shell: bash
        run: |
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          nvm use 22.16.0 || nvm install 22.16.0
          echo "Node.js version: $(node --version)"

      - name: Run agent failure handler
        id: agent-fix
        if: steps.iteration.outputs.exceeded_max != 'true'
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH_NAME: ${{ github.head_ref }}
          ITERATION_COUNT: ${{ steps.iteration.outputs.iteration_count }}
        run: |
          echo "Running agent failure handler..."
          echo "Format check result: $FORMAT_CHECK_RESULT"
          echo "Basic lint result: $BASIC_LINT_RESULT"
          echo "Full lint result: $FULL_LINT_RESULT"

          ./automation/ci-cd/agent-failure-handler.sh \
            "$PR_NUMBER" \
            "$BRANCH_NAME" \
            "$ITERATION_COUNT" \
            "5" \
            "format,lint"

      - name: Log result
        if: always()
        run: |
          echo "Agent failure handler completed"
          echo "Made changes: ${{ steps.agent-fix.outputs.made_changes || 'false' }}"
          echo "Iteration: ${{ steps.iteration.outputs.iteration_count }}"

  # Final status and summary
  pr-status:
    name: PR Status Summary
    needs:
      - detect-changes
      - gemini-review
      - codex-review
      - agent-review-response
      - format-check
      - basic-lint
      - full-lint
      - link-check
      - config-validation
      - workflow-validation
      - yaml-lint
      - test-suite
      - mcp-validation
      - sleeper-agents-tests
      - dashboard-tests
      - gaea2-integration-tests
      - docker-validation
      - agent-failure-handler
    if: always()
    runs-on: self-hosted
    steps:
      - name: Generate status summary
        run: |
          echo "## PR Validation Summary"
          echo ""
          echo "**Files changed:** ${{ needs.detect-changes.outputs.files_changed }}"
          echo "**Python files:** ${{ needs.detect-changes.outputs.python_changed }}"
          echo "**Config files:** ${{ needs.detect-changes.outputs.yaml_changed }}"
          echo "**Docker files:** ${{ needs.detect-changes.outputs.docker_changed }}"
          echo "**MCP files:** ${{ needs.detect-changes.outputs.mcp_changed }}"
          echo "**Dashboard files:** ${{ needs.detect-changes.outputs.dashboard_changed }}"
          echo ""
          echo "**Validation Results:**"
          echo "- Change Detection: ${{ needs.detect-changes.result }}"
          echo "- Gemini AI Review: ${{ needs.gemini-review.result }}"
          echo "- Codex AI Review: ${{ needs.codex-review.result }}"
          echo "- Format Check: ${{ needs.format-check.result }}"
          echo "- Basic Lint: ${{ needs.basic-lint.result }}"
          echo "- Full Lint: ${{ needs.full-lint.result }}"
          echo "- Link Check: ${{ needs.link-check.result }}"
          echo "- Config Validation: ${{ needs.config-validation.result }}"
          echo "- Workflow Validation: ${{ needs.workflow-validation.result }}"
          echo "- YAML Lint: ${{ needs.yaml-lint.result }}"
          echo "- Test Suite: ${{ needs.test-suite.result }}"
          echo "- MCP Validation: ${{ needs.mcp-validation.result }}"
          echo "- sleeper agents: ${{ needs.sleeper-agents-tests.result }}"
          echo "- Dashboard Tests: ${{ needs.dashboard-tests.result }}"
          echo "- Gaea2 Integration Tests: ${{ needs.gaea2-integration-tests.result }}"
          echo "- Docker Validation: ${{ needs.docker-validation.result }}"

          # Check for failures (AI reviews are advisory, not blocking)
          if [[ "${{ needs.detect-changes.result }}" == "failure" ||
                "${{ needs.format-check.result }}" == "failure" ||
                "${{ needs.basic-lint.result }}" == "failure" ||
                "${{ needs.full-lint.result }}" == "failure" ||
                "${{ needs.link-check.result }}" == "failure" ||
                "${{ needs.config-validation.result }}" == "failure" ||
                "${{ needs.workflow-validation.result }}" == "failure" ||
                "${{ needs.yaml-lint.result }}" == "failure" ||
                "${{ needs.test-suite.result }}" == "failure" ||
                "${{ needs.mcp-validation.result }}" == "failure" ||
                "${{ needs.sleeper-agents-tests.result }}" == "failure" ||
                "${{ needs.dashboard-tests.result }}" == "failure" ||
                "${{ needs.gaea2-integration-tests.result }}" == "failure" ||
                "${{ needs.docker-validation.result }}" == "failure" ]]; then
            echo ""
            echo "‚ùå PR validation failed - please review the failed checks"
            exit 1
          fi

          echo ""
          echo "‚úÖ PR validation completed successfully!"

      - name: Post PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const results = {
              'change-detection': '${{ needs.detect-changes.result }}',
              'gemini-review': '${{ needs.gemini-review.result }}',
              'codex-review': '${{ needs.codex-review.result }}',
              'format-check': '${{ needs.format-check.result }}',
              'basic-lint': '${{ needs.basic-lint.result }}',
              'full-lint': '${{ needs.full-lint.result }}',
              'link-check': '${{ needs.link-check.result }}',
              'config-validation': '${{ needs.config-validation.result }}',
              'workflow-validation': '${{ needs.workflow-validation.result }}',
              'yaml-lint': '${{ needs.yaml-lint.result }}',
              'test-suite': '${{ needs.test-suite.result }}',
              'mcp-validation': '${{ needs.mcp-validation.result }}',
              'sleeper-agents': '${{ needs.sleeper-agents-tests.result }}',
              'dashboard-tests': '${{ needs.dashboard-tests.result }}',
              'gaea2-integration-tests': '${{ needs.gaea2-integration-tests.result }}',
              'docker-validation': '${{ needs.docker-validation.result }}'
            };

            const filesChanged = '${{ needs.detect-changes.outputs.files_changed }}';
            const isDraft = context.payload.pull_request.draft;

            let comment = '## üîç PR Validation Results\n\n';
            comment += `**Files changed:** ${filesChanged}\n\n`;
            comment += '| Check | Status |\n|-------|--------|\n';

            Object.entries(results).forEach(([check, status]) => {
              let icon = status === 'success' ? '‚úÖ' :
                        status === 'failure' ? '‚ùå' :
                        status === 'skipped' ? '‚è≠Ô∏è' : 'üîÑ';

              let displayName = check.charAt(0).toUpperCase() + check.slice(1).replace('-', ' ');
              comment += `| ${displayName} | ${icon} |\n`;
            });

            if (isDraft) {
              comment += '\n> üí° **Draft PR** - Some validations may be skipped.\n';
            }

            comment += '\nü§ñ *Generated by automated PR validation*';

            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (error) {
              console.log('Could not post comment:', error.message);
            }
