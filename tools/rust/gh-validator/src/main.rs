//! gh-validator: GitHub CLI wrapper for comment validation and secret masking
//!
//! This binary intercepts `gh` commands and performs validation before
//! delegating to the real `gh` binary.
//!
//! # Usage
//!
//! Install this binary as `gh` in a higher-priority PATH directory.
//! It will automatically find and call the real `gh` binary.
//!
//! # Validation
//!
//! - Secret masking: Detects and masks secrets in comment content
//! - Unicode emoji detection: Blocks emojis that may display incorrectly
//! - Formatting validation: Ensures proper use of --body-file for reaction images
//! - URL validation: Verifies reaction image URLs exist (with SSRF protection)
//!
//! # Post-Command Features
//!
//! - PR monitoring reminder: After `gh pr create`, displays a reminder to monitor
//!   the PR for feedback using the pr-monitor tool.
//!
//! # Architecture
//!
//! All validation operates directly on the argument vector rather than
//! reconstructing command strings. This provides robust validation that
//! cannot be bypassed through shell escaping tricks.
//!
//! # Special Flags
//!
//! - `--gh-validator-strip-invalid-images`: Instead of failing on invalid image
//!   URLs, strip them from the content and continue. Useful for CI pipelines.

use std::env;
use std::process::{exit, Command, Stdio};

use wrapper_common::audit::{AuditAction, AuditEntry};

/// gh-validator specific flag for stripping invalid images instead of failing
const STRIP_INVALID_IMAGES_FLAG: &str = "--gh-validator-strip-invalid-images";

mod config;
mod error;
mod gh_finder;
mod validation;

use config::load_config;
use error::Error;
use validation::{CommentValidator, SecretMasker, UrlValidator};

// Include compile-time source hash (generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/integrity.rs"));

/// Arguments that indicate we need to validate content
/// Includes both long and short flags from gh CLI
const CONTENT_ARGS: &[&str] = &[
    "--body",
    "-b", // short for --body
    "--body-file",
    "-F", // short for --body-file
    "--notes",
    "-n", // short for --notes
    "--notes-file",
    "--title",
    "-t", // short for --title
    "--message",
    "-m", // short for --message
];

/// Check if args contain any content-posting flags
fn needs_validation(args: &[String]) -> bool {
    args.iter().any(|arg| {
        CONTENT_ARGS.iter().any(|ca| {
            // Exact match (e.g., "--body")
            arg == *ca
                // Match with = value (e.g., "--body=content")
                || arg.starts_with(&format!("{}=", ca))
        })
    })
}

/// Extract --body-file/-F path from arguments
fn extract_body_file(args: &[String]) -> Option<String> {
    let mut iter = args.iter().peekable();
    while let Some(arg) = iter.next() {
        // Handle --body-file and -F (short form)
        if arg == "--body-file" || arg == "-F" {
            return iter.next().cloned();
        }
        if let Some(path) = arg.strip_prefix("--body-file=") {
            return Some(path.to_string());
        }
        // Handle -F=path form (rare but possible)
        if let Some(path) = arg.strip_prefix("-F=") {
            return Some(path.to_string());
        }
    }
    None
}

/// Check if --body-file/-F is reading from stdin (blocked for security)
fn is_stdin_body_file(args: &[String]) -> bool {
    let mut iter = args.iter().peekable();
    while let Some(arg) = iter.next() {
        // Handle --body-file and -F (short form)
        if arg == "--body-file" || arg == "-F" {
            if let Some(next) = iter.next() {
                if next == "-" {
                    return true;
                }
            }
        }
        // Handle combined forms
        if arg == "--body-file=-" || arg == "-F=-" || arg == "-F-" {
            return true;
        }
    }
    false
}

/// Check if strip-invalid-images flag is present and remove it from args
fn extract_strip_flag(args: &[String]) -> (Vec<String>, bool) {
    let has_flag = args.iter().any(|a| a == STRIP_INVALID_IMAGES_FLAG);
    let filtered: Vec<String> = args
        .iter()
        .filter(|a| *a != STRIP_INVALID_IMAGES_FLAG)
        .cloned()
        .collect();
    (filtered, has_flag)
}

/// Flags that take an argument (used to skip their values in positional detection)
const FLAGS_WITH_ARGS: &[&str] = &[
    "-R",
    "--repo",
    "-C",
    "--cwd",
    "-H",
    "--hostname",
    "--jq",
    "-t",
    "--template",
];

/// Check if this is a `gh pr create` command
///
/// Properly detects the subcommand by ensuring "pr" and "create" appear
/// as the first two non-flag arguments in sequence. This avoids false
/// positives like `gh pr list --search create` and handles global flags
/// with arguments like `gh -R owner/repo pr create`.
fn is_pr_create_command(args: &[String]) -> bool {
    let mut positional = Vec::new();
    let mut skip_next = false;

    for arg in args {
        if skip_next {
            skip_next = false;
            continue;
        }
        if arg.starts_with('-') {
            // Check if this flag takes an argument
            if FLAGS_WITH_ARGS.iter().any(|f| arg == *f) {
                skip_next = true;
            }
            // Also handle --flag=value form (no need to skip next)
            continue;
        }
        positional.push(arg);
    }

    // Check if first two positional args are "pr" and "create"
    positional.len() >= 2 && positional[0] == "pr" && positional[1] == "create"
}

/// Extract --repo/-R value from args if present
fn extract_repo_flag(args: &[String]) -> Option<String> {
    let mut iter = args.iter();
    while let Some(arg) = iter.next() {
        if arg == "-R" || arg == "--repo" {
            return iter.next().cloned();
        }
        if let Some(repo) = arg.strip_prefix("--repo=") {
            return Some(repo.to_string());
        }
        if let Some(repo) = arg.strip_prefix("-R") {
            if !repo.is_empty() {
                return Some(repo.to_string());
            }
        }
    }
    None
}

/// Print the PR monitoring reminder
fn print_pr_monitoring_notice(pr_number: u32, pr_url: &str) {
    // Get the latest commit SHA
    let commit_sha = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|o| {
            if o.status.success() {
                String::from_utf8(o.stdout)
                    .ok()
                    .map(|s| s.trim().to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| "HEAD".to_string());

    // Get current branch name
    let branch = Command::new("git")
        .args(["rev-parse", "--abbrev-ref", "HEAD"])
        .output()
        .ok()
        .and_then(|o| {
            if o.status.success() {
                String::from_utf8(o.stdout)
                    .ok()
                    .map(|s| s.trim().to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| "unknown".to_string());

    eprintln!();
    eprintln!("============================================================");
    eprintln!("PR FEEDBACK MONITORING");
    eprintln!("============================================================");
    eprintln!();
    eprintln!("PR #{} created on branch '{}'", pr_number, branch);
    eprintln!("{}", pr_url);
    eprintln!();
    eprintln!("To monitor for admin/Gemini feedback:");
    eprintln!();
    eprintln!(
        "  ./tools/rust/pr-monitor/target/release/pr-monitor {} --since-commit {}",
        pr_number, commit_sha
    );
    eprintln!();
    eprintln!("This will watch for:");
    eprintln!("  - Admin comments and approval commands");
    eprintln!("  - Gemini AI code review feedback");
    eprintln!("  - CI/CD validation results");
    eprintln!();
    eprintln!("============================================================");
}

/// Run validation and execute the real gh binary
fn run() -> Result<(), Error> {
    let raw_args: Vec<String> = env::args().skip(1).collect();

    // Check for --wrapper-integrity flag
    if wrapper_common::integrity::check_integrity_flag(&raw_args, "gh-validator", SOURCE_HASH) {
        return Ok(());
    }

    // Extract gh-validator specific flags (not passed to real gh)
    let (args, strip_invalid_images) = extract_strip_flag(&raw_args);

    // Find real gh binary (skip ourselves)
    let real_gh = gh_finder::find_real_gh()?;

    // Fast path: if no content args (--body, --body-file, etc.), exec immediately
    // Note: We validate ANY command with content args, not just "pr comment"
    // This prevents bypasses like "gh pr --repo x comment --body secret"
    if !needs_validation(&args) {
        // Log allowed operation (fast path, no validation needed)
        let entry = AuditEntry::new(
            "gh-validator",
            AuditAction::Allowed,
            args.clone(),
            &real_gh.to_string_lossy(),
            SOURCE_HASH,
        );
        wrapper_common::audit::log_event(&entry);

        exec_gh(&real_gh, &args)?;
        unreachable!("exec should not return");
    }

    // Load config (fail-closed if missing)
    let config = load_config()?;

    // Initialize validators
    let masker = SecretMasker::new(&config);
    let url_validator = UrlValidator::default();

    // Helper closure to log blocked operations before returning errors
    let log_blocked = |reason: &str, blocked_args: &[String]| {
        let entry = AuditEntry::new(
            "gh-validator",
            AuditAction::Blocked,
            blocked_args.to_vec(),
            &real_gh.to_string_lossy(),
            SOURCE_HASH,
        )
        .with_blocked_reason(reason.to_string());
        wrapper_common::audit::log_event(&entry);
    };

    // 1. Check for stdin usage (blocked for security) - check args directly
    if is_stdin_body_file(&args) {
        log_blocked("stdin body file blocked for security", &args);
        return Err(Error::StdinBlocked);
    }

    // 2. Mask secrets in individual arguments (avoids shell escaping issues)
    let (masked_args, was_masked) = masker.mask_args(&args);

    // 3. Check Unicode emojis in args (operates directly on arg vector)
    if CommentValidator::args_post_content(&masked_args) {
        if let Some(emoji) = CommentValidator::check_unicode_emoji_in_args(&masked_args) {
            log_blocked(
                &format!("unicode emoji U+{:04X} blocked", emoji as u32),
                &masked_args,
            );
            return Err(Error::UnicodeEmoji {
                char: emoji,
                codepoint: emoji as u32,
            });
        }
    }

    // 4. Check formatting violations (operates directly on arg vector)
    // This catches --body/-b with reaction images (should use --body-file instead)
    if let Some(violation) = CommentValidator::check_formatting_violations_in_args(&masked_args) {
        log_blocked(
            &format!("formatting violation: {}", violation),
            &masked_args,
        );
        return Err(Error::FormattingViolation {
            description: violation.to_string(),
        });
    }

    // 5. Validate URLs in --body-file (use original args for file path)
    if let Some(file_path) = extract_body_file(&args) {
        match std::fs::read_to_string(&file_path) {
            Ok(content) => {
                if strip_invalid_images {
                    // Strip mode: remove invalid images and continue
                    let (new_content, stripped) = url_validator.strip_invalid_images(&content);
                    if !stripped.is_empty() {
                        for (url, reason) in &stripped {
                            eprintln!(
                                "[gh-validator] WARNING: Stripped invalid image: {} ({})",
                                url, reason
                            );
                        }

                        // Check if content is empty after stripping
                        if new_content.trim().is_empty() {
                            eprintln!(
                                "[gh-validator] WARNING: Content is empty after stripping {} invalid image(s), skipping command",
                                stripped.len()
                            );
                            // Exit successfully - the comment would fail with empty body
                            exit(0);
                        }

                        // Write modified content back to the file
                        if let Err(e) = std::fs::write(&file_path, &new_content) {
                            return Err(Error::BodyFileRead {
                                path: file_path,
                                reason: format!("Failed to write modified content: {}", e),
                            });
                        }
                        eprintln!(
                            "[gh-validator] Removed {} invalid image(s), continuing with comment",
                            stripped.len()
                        );
                    }
                } else {
                    // Strict mode: fail on any invalid URL
                    let urls = UrlValidator::extract_reaction_urls(&content);
                    for url in urls {
                        if let Err(e) = url_validator.validate_exists(&url) {
                            log_blocked(&format!("invalid URL: {}", url), &masked_args);
                            return Err(e);
                        }
                    }
                }
            },
            Err(e) => {
                // Only error if the file is supposed to exist
                // (might be created by a previous command in a pipeline)
                if std::path::Path::new(&file_path).exists() {
                    return Err(Error::BodyFileRead {
                        path: file_path,
                        reason: e.to_string(),
                    });
                }
            },
        }
    }

    // 6. Execute gh with masked arguments
    if was_masked {
        eprintln!("[gh-validator] Secrets were masked in command");
    }

    // Log allowed operation (validation passed)
    let entry = AuditEntry::new(
        "gh-validator",
        AuditAction::Allowed,
        masked_args.clone(),
        &real_gh.to_string_lossy(),
        SOURCE_HASH,
    );
    wrapper_common::audit::log_event(&entry);

    // Special handling for `gh pr create` - use spawn to capture output for monitoring notice
    if is_pr_create_command(&masked_args) {
        return spawn_gh_pr_create(&real_gh, &masked_args);
    }

    exec_gh(&real_gh, &masked_args)?;

    unreachable!("exec should not return");
}

/// Execute `gh pr create` and show monitoring notice after success
///
/// Unlike exec_gh, this spawns the process so we can:
/// 1. Let gh run with full TTY access (preserves interactive mode)
/// 2. Query for the PR URL after completion
/// 3. Print the monitoring notice
///
/// Note: We use inherited stdout/stderr to preserve TTY for interactive prompts.
/// After the command succeeds, we query the PR URL using `gh pr view`.
fn spawn_gh_pr_create(gh_path: &std::path::Path, args: &[String]) -> Result<(), Error> {
    // Run gh with inherited stdio to preserve TTY for interactive mode
    let status = Command::new(gh_path)
        .args(args)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .stdin(Stdio::inherit())
        .status()
        .map_err(Error::ExecFailed)?;

    // If successful, query for the PR URL and show monitoring notice
    if status.success() {
        // Extract repo flag from original args to pass to gh pr view
        let repo = extract_repo_flag(args);
        // Get the PR URL for the current branch using gh pr view
        if let Some((pr_number, pr_url)) = get_current_branch_pr(gh_path, repo.as_deref()) {
            print_pr_monitoring_notice(pr_number, &pr_url);
        }
    }

    // Exit with the same code as gh
    exit(status.code().unwrap_or(1));
}

/// Get PR number and URL for the current branch
fn get_current_branch_pr(gh_path: &std::path::Path, repo: Option<&str>) -> Option<(u32, String)> {
    // Build args, optionally including --repo
    let mut cmd_args = vec!["pr", "view", "--json", "number,url"];
    let repo_flag;
    if let Some(r) = repo {
        repo_flag = format!("--repo={}", r);
        cmd_args.push(&repo_flag);
    }

    let output = Command::new(gh_path).args(&cmd_args).output().ok()?;

    if !output.status.success() {
        return None;
    }

    let json_str = String::from_utf8(output.stdout).ok()?;

    // Parse JSON manually (avoid adding serde dependency)
    // Format: {"number":123,"url":"https://..."} or {"number": 123, "url": "..."}
    // Handle optional whitespace after colons
    let number = json_str.find("\"number\":").and_then(|i| {
        let start = i + 9;
        let rest = json_str[start..].trim_start();
        let end = rest
            .find(|c: char| !c.is_ascii_digit())
            .unwrap_or(rest.len());
        if end == 0 {
            return None;
        }
        rest[..end].parse::<u32>().ok()
    })?;

    let url = json_str.find("\"url\":").and_then(|i| {
        let start = i + 6;
        let rest = json_str[start..].trim_start();
        // Skip opening quote
        let rest = rest.strip_prefix('"')?;
        let end = rest.find('"')?;
        Some(rest[..end].to_string())
    })?;

    Some((number, url))
}

/// Execute the real gh binary (replaces current process on Unix)
#[cfg(unix)]
fn exec_gh(gh_path: &std::path::Path, args: &[String]) -> Result<(), Error> {
    use std::os::unix::process::CommandExt;

    let err = Command::new(gh_path).args(args).exec();

    // exec() only returns on error
    Err(Error::ExecFailed(err))
}

/// Execute the real gh binary (Windows doesn't have exec, use spawn)
#[cfg(windows)]
fn exec_gh(gh_path: &std::path::Path, args: &[String]) -> Result<(), Error> {
    let status = Command::new(gh_path)
        .args(args)
        .status()
        .map_err(Error::ExecFailed)?;

    std::process::exit(status.code().unwrap_or(1));
}

fn main() {
    if let Err(e) = run() {
        eprintln!("ERROR: {}", e);

        // Print help text if available
        if let Some(help) = e.help_text() {
            eprintln!();
            eprintln!("{}", help);
        }

        exit(1);
    }
}
